//+=============================================================================
//
// file :         CTExpChannel.cpp
//
// description :  C++ source for the CTExpChannel and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                CTExpChannel are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author$
//
// $Revision$
//
// $Log$
// Revision 1.18  2007/09/07 15:00:07  tcoutinho
// safety commit
//
// Revision 1.17  2007/08/30 12:40:39  tcoutinho
// - changes to support Pseudo counters.
//
// Revision 1.16  2007/08/17 13:07:29  tcoutinho
// - pseudo motor restructure
// - pool base dev class restructure
// - initial commit for pseudo counters
//
// Revision 1.15  2007/07/26 07:05:42  tcoutinho
// fix bug 10 : Change all tango commands from Stop to Abort
//
// Revision 1.14  2007/05/30 14:37:24  etaurel
// - In inform_ghost() method, dont propagate event if the old_state is
// MOVING. It will be done by the "action" thread
//
// Revision 1.13  2007/05/25 12:48:10  tcoutinho
// fix the same dead locks found on motor system to the acquisition system since release labeled for Josep Ribas
//
// Revision 1.12  2007/05/22 13:43:09  tcoutinho
// - added new method
//
// Revision 1.11  2007/05/15 07:17:45  etaurel
// - Re-insert device in ghost group in case of Init command
//
// Revision 1.10  2007/02/22 11:52:55  tcoutinho
// - added support for ghost measurement group
//
// Revision 1.9  2007/02/16 10:02:42  tcoutinho
// - new method to set the state coming from a measurement group (maybe in the future move it to the super class)
//
// Revision 1.8  2007/02/08 16:18:13  tcoutinho
// - controller safety on PoolGroupBaseDev
//
// Revision 1.7  2007/02/08 10:49:57  etaurel
// - Some small changes after the merge
//
// Revision 1.6  2007/02/08 07:55:00  etaurel
// - Changes after compilation -Wall. Some small changes
//
// Revision 1.5  2007/01/30 16:41:58  etaurel
// - Fix bug in PoolBaseDev data member initialization
//
// Revision 1.4  2007/01/30 15:56:28  etaurel
// - Fix some memory leaks
// - Value is now a Double attribute
//
// Revision 1.3  2007/01/16 16:50:03  etaurel
// - It's now possible to write the Value attribute
//
// Revision 1.2  2007/01/16 14:23:18  etaurel
// - First release with Counter Timer
//
// Revision 1.1  2007/01/05 15:03:14  etaurel
// - First implementation of the Counter Timer class
//
//
// copyleft :   CELLS/ALBA
//		Edifici Ciences Nord
//		Campus Universitari de Bellaterra
//		Universitat Autonoma de Barcelona
//		08193 Bellaterra, Barcelona, SPAIN
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//=============================================================================



//===================================================================
//
//	The following table gives the correspondance
//	between commands and method's name.
//
//  Command's name|  Method's name
//	----------------------------------------
//  State   |  dev_state()
//  Status  |  dev_status()
//  Start   |  start()
//  Abort   |  abort()
//
//===================================================================

#include "CtrlFiCa.h"
#include <tango.h>
#include "Pool.h"
#include "PoolUtil.h"
#include "CTExpChannel.h"
#include "CTExpChannelClass.h"
#include "CTExpChannelUtil.h"
#include "CTPoolThread.h"
#include <pool/CoTiCtrl.h>



namespace CTExpChannel_ns
{

//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::CTExpChannel(string &s)
// 
// description : 	constructor for simulated CTExpChannel
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
CTExpChannel::CTExpChannel(Tango::DeviceClass *cl,string &s)
//:Tango::Device_4Impl(cl,s.c_str())
:Pool_ns::PoolIndBaseDev(cl,s.c_str())
{
    init_cmd = false;
    init_device();
}

CTExpChannel::CTExpChannel(Tango::DeviceClass *cl,const char *s)
//:Tango::Device_4Impl(cl,s.c_str())
:Pool_ns::PoolIndBaseDev(cl,s)
{
    init_cmd = false;
    init_device();
}

CTExpChannel::CTExpChannel(Tango::DeviceClass *cl,const char *s,const char *d)
//:Tango::Device_4Impl(cl,s.c_str())
:Pool_ns::PoolIndBaseDev(cl,s,d)
{
    init_cmd = false;
    init_device();
}

//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void CTExpChannel::delete_device()
{
    //	Delete device's allocated object
    
//
// To know that we are executing this code due to a pool shutdown and not due to a
// "Init" command, we are using the polling thread ptr which is cleared in the DS
// shutdown sequence before the device destruction
//
    bool sd = false;

    Tango::Util *tg = Tango::Util::instance();
    if (tg->get_polling_thread_object() != NULL)
    {
        if (get_state() == Tango::MOVING)
        {
            TangoSys_OMemStream o;
            o << "Init command on counter timer device is not allowed while a counter timer is counting" << ends;

            Tango::Except::throw_exception((const char *)"CTExp_InitNotAllowed",o.str(),
                    (const char *)"CTExpChannel::delete_device");
        }
    }
    else
    {
        sd = true;
    }

//
// If we are not in a shutdown sequence:
// Lock the ghost group in order the polling thread not to
// start requesting for motor state while we are deleting it and
// inform ghost group that there is one channel less
//
// If we are called due to a Init command on the DServer admin,
// the measurement_group class is already deleted and the ghost group
// as well
//

    if (sd == false)
    {
        bool measurementgroup_class_deleted = false;
        MeasurementGroup_ns::MeasurementGroup *ghost_ptr;
        
        try
        {
            ghost_ptr = pool_dev->get_ghost_measurement_group_ptr();
        }
        catch (Tango::DevFailed &e)
        {
            measurementgroup_class_deleted = true;
        }
        
        if (measurementgroup_class_deleted == false)
        {
            Tango::AutoTangoMonitor atm(ghost_ptr);
            ghost_ptr->remove_channel_from_ghost_group(get_id());
        }
    }

    
//
// Delete the device from its controller and from the pool
//
    // If in shutdown mode, protect against exceptions
    if (sd)
    {
        try
        {
            delete_from_pool();
        }
        catch(Tango::DevFailed &df)
        {
            std::cout << "Error deleting '"<< get_name()
                      << "' from controller:" << std::endl;
            Tango::Except::print_exception(df);
        }
        catch(...)
        {
            std::cout << "Unknown error deleting '"<< get_name()
                      << "' from controller." << std::endl;
        }        
    }
    else
    {
        delete_from_pool();
    }
    delete_utils();
    
    PoolIndBaseDev::delete_device();    
}

//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void CTExpChannel::init_device()
{
    INFO_STREAM << "CTExpChannel::CTExpChannel() create device " << device_name << endl;

    // Initialise variables to default values
    //--------------------------------------------
    PoolIndBaseDev::init_device();

//
// Init some variables
//
    
    attr_Value_read = &read_value;
    
//
// We will push change event on State and Value attributes
//

    Tango::Attribute &state_att = dev_attr->get_attr_by_name("state");
    state_att.set_change_event(true,false);
    
    Tango::Attribute &val_att = dev_attr->get_attr_by_name("Value");
    val_att.set_change_event(true);
        
//
// Build the PoolBaseUtils class depending on the
// controller type
//

    set_utils(new CTExpChannelUtil(pool_dev));
    
//
// Inform Pool of our birth
//

    Pool_ns::CTExpChannelPool *ct_pool_ptr = new Pool_ns::CTExpChannelPool;
    init_pool_element(ct_pool_ptr);
    
    {
        Tango::AutoTangoMonitor atm(pool_dev);
        pool_dev->add_element(ct_pool_ptr);
    }

//
// Inform controller of our birth
//

    a_new_child(ct_pool_ptr->get_ctrl_id());
    
//
// If we are called due to a init command, update our info in the
// ghost group
//
        
    if (init_cmd == true)
    {
        MeasurementGroup_ns::MeasurementGroup *ghost_ptr = pool_dev->get_ghost_measurement_group_ptr();
        {
            Tango::AutoTangoMonitor atm(ghost_ptr);
            ghost_ptr->add_ct_to_ghost_group(get_id());
        }
        init_cmd = false;
    }
}

Pool_ns::CTExpChannelPool &CTExpChannel::get_countertimer_element()
{
    return static_cast<Pool_ns::CTExpChannelPool &>(get_pool_element());
}

//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void CTExpChannel::get_device_property()
{
    //	Initialize your default values here (if not done with  POGO).
    //------------------------------------------------------------------
    PoolIndBaseDev::get_device_property();
    
    //	Read device properties from database.(Automatic code generation)
    //------------------------------------------------------------------

    //	End of Automatic code generation
    //------------------------------------------------------------------

}
//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------

void CTExpChannel::always_executed_hook()
{

    base_always_executed_hook(false);

}

//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::inform_ghost
// 
// description : 	inform ghost group of a change in the state
//
//-----------------------------------------------------------------------------
void CTExpChannel::inform_ghost(Tango::DevState old_state,Tango::DevState new_state)
{

    if (old_state != Tango::MOVING)
    {	
        if(old_state != new_state && 
           new_state != Tango::ON &&
           new_state != Tango::MOVING)
        {
            MeasurementGroup_ns::MeasurementGroup *ghost = pool_dev->get_ghost_measurement_group_ptr();
            long idx = ghost->get_ind_elt_idx_from_id(get_id());
            Tango::AutoTangoMonitor synch(ghost);
            ghost->update_state_from_ctrls(idx,new_state);
        }	
    }	
}

//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void CTExpChannel::read_attr_hardware(vector<long> &attr_list)
{
    DEBUG_STREAM << "CTExpChannel::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
    //	Add your own code here
}
//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::write_Value
// 
// description : 	Write Value attribute values to hardware.
//
//-----------------------------------------------------------------------------
void CTExpChannel::write_Value(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "CTExpChannel::write_Value(Tango::WAttribute &attr) entering... "<< endl;
 
    Pool_ns::CTExpChannelPool &ct_element = get_countertimer_element();
       
    double old_value = attr_Value_write;
    attr.get_write_value(attr_Value_write);
    DEBUG_STREAM << "CTExpChannel:: new value = " << attr_Value_write << endl;
/*
    if (attr_Value_write < 0.0)
    {
        attr_Value_write = old_value;
        Tango::Except::throw_exception((const char *)"CTExpChannel_BadArgument",
                      (const char *)"Value cannot be negative",
                      (const char *)"CTExpChannel::write_Value");
    }
*/
    if (!ct_element.get_simulation_mode())
    {
        Pool_ns::AutoPoolLock lo(fica_ptr->get_mon());
        CoTiController *typed_ctrl = static_cast<CoTiController *>(ct_element.get_controller());
        
        bool res = false;
        try
        {
            typed_ctrl->PreLoadAll();
            res = typed_ctrl->PreLoadOne(get_axis(),attr_Value_write);
        }
        SAFE_CATCH(fica_ptr->get_name(),"write_Value");
        
        if (res == false)
        {
            attr_Value_write = old_value;
            Tango::Except::throw_exception((const char *)"CTExpChannel_BadArgument",
                      (const char *)"Value refused by controller. Its PreLoadOne() method returns false",
                      (const char *)"CTExpChannel::write_Value");
        }

        try
        {			
            typed_ctrl->LoadOne(get_axis(),attr_Value_write);
            typed_ctrl->LoadAll();
        }
        SAFE_CATCH(fica_ptr->get_name(),"write_Value");
    }

}

//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::read_Value
// 
// description : 	Extract real attribute values for Value acquisition result.
//
//-----------------------------------------------------------------------------
void CTExpChannel::read_Value(Tango::Attribute &attr)
{
    DEBUG_STREAM << "CTExpChannel::read_Value(Tango::Attribute &attr) entering... "<< endl;
    
    Pool_ns::CTExpChannelPool &ct_element = get_countertimer_element();
    
    if (!ct_element.get_simulation_mode())
    {
        if(!is_fica_built())
        {
            Tango::Except::throw_exception("CTExpChannel_BadController",
                  "The CounterTimer controller class has not been built",
                  "CTExpChannel::read_Value");
        }
        Pool_ns::AutoPoolLock lo(fica_ptr->get_mon());

        double ctr_value = 0.0;
        try
        {
            CoTiController *typed_ctrl = static_cast<CoTiController *>(ct_element.get_controller());
            
            typed_ctrl->PreReadAll();
            typed_ctrl->PreReadOne(get_axis());
            typed_ctrl->ReadAll();
            ctr_value = typed_ctrl->ReadOne(get_axis());
        }
        SAFE_CATCH(fica_ptr->get_name(),"read_Value");
        
        if (ctr_value == LONG_MAX)
        {
            Tango::Except::throw_exception((const char *)"CTExpChannel_BadController",
                  (const char *)"The CounterTimer controller class has not re-defined method to read value (readOne(...))",
                  (const char *)"CTExpChannel::read_Value");
        }
        else
            read_value = ctr_value;
    }
    else
    {
        read_value = 0.0;
    }
    
    attr.set_value(attr_Value_read);

    Tango::DevState ct_sta = get_state();

//
// Set the attribute quality factor
//
    
    if (ct_sta == Tango::MOVING)
        attr.set_quality(Tango::ATTR_CHANGING);
}


//+------------------------------------------------------------------
/**
 *	method:	CTExpChannel::start
 *
 *	description:	method to execute "Start"
 *	Start counting
 *
 *
 */
//+------------------------------------------------------------------
void CTExpChannel::start()
{
    DEBUG_STREAM << "CTExpChannel::start(): entering... !" << endl;
    
    Pool_ns::CTExpChannelPool &ct_element = get_countertimer_element();
    
    //	Add your own code to control device here

    //
    // Start the thread doing the job
    //	
                    
        if (!ct_element.get_simulation_mode())
        {
            Pool_ns::AquisitionInfo aq_info;
            
            aq_info.master_id = get_id();
            aq_info.master_value = 0.0;
            aq_info.mode = Pool_ns::aqNone;
            aq_info.master_idx_in_cts = 0;
            aq_info.master_idx_in_grp = 0;
            aq_info.ct_ids.push_back(get_id());
    
            th_failed = false;
            abort_cmd_executed = false;
                
    //
    // Create the counting thread, but start it only while the mon
    // lock is taken. Otherwise, a dead-lock can happen, if the thread
    // start executing its code just after the start and before this code
    // enter into the wait. The thread will send the signal but while
    // this thread is not yet waiting for it and afterwards, we will have
    // a dead-lock...
    //
            Pool_ns::PoolMonitor *mon = ct_element.get_notification_monitor();
            Pool_ns::CTPoolThread *ct_pool_th = 
                new Pool_ns::CTPoolThread(aq_info, pool_dev, mon);
    
            {
                omni_mutex_lock lo(*mon);
                ct_pool_th->start();
                mon->wait();
            }
            
            if (th_failed == true)
            {
                Tango::DevFailed ex(th_except);
                throw ex;
            }
        }
        else
        {
            
    //
    // Fire events on state and value like the couting thread is doing
    //
    
            Tango::Attribute &state_att = dev_attr->get_attr_by_name("state");
            set_state(Tango::MOVING);
            state_att.fire_change_event();
            
            set_state(Tango::ON);
            state_att.fire_change_event();
    
            Tango::Attribute &val_att = dev_attr->get_attr_by_name("Value");
            read_Value(val_att);
            val_att.set_change_event(true,false);
            val_att.fire_change_event();
            val_att.set_change_event(true);
        }		

}

//+------------------------------------------------------------------
/**
 *	method:	CTExpChannel::abort
 *
 *	description:	method to execute "Abort"
 *	Stop counting
 *
 *
 */
//+------------------------------------------------------------------
void CTExpChannel::abort()
{
    DEBUG_STREAM << "CTExpChannel::stop(): entering... !" << endl;

    //	Add your own code to control device here
    base_abort(true);
}

void CTExpChannel::base_abort(bool send_evt)
{
    Pool_ns::CTExpChannelPool &ct_element = get_countertimer_element();
//
// Do nothing if the counter is not counting
//

    if (get_state() != Tango::MOVING)
        return;
        
//
// Send abort command to the controller
//

    if (!ct_element.get_simulation_mode())
    {
        Pool_ns::AutoPoolLock lo(fica_ptr->get_mon());
        CoTiController *typed_ctrl = static_cast<CoTiController *>(ct_element.get_controller());
        
        try
        {
            typed_ctrl->AbortOne(get_axis());
        }
        SAFE_CATCH(fica_ptr->get_name(),"abort");

        if(send_evt)
        {
            abort_cmd_executed = true;		

            always_executed_hook();
            
            Tango::MultiAttribute *dev_attrs = get_device_attr();
            Tango::Attribute &state_att = dev_attrs->get_attr_by_name("State");
            state_att.fire_change_event();
            //
            // Value attribute quality factor is VALID
            //
            Tango::WAttribute &val_att = dev_attrs->get_w_attr_by_name("Value");
            val_att.set_quality(Tango::ATTR_VALID);
        }
    }
    else
    {
        Tango::Except::throw_exception((const char *)"CTExpChannel_SimuMode",
                                       (const char *)"Command not allowed when counter is in simulation mode",
                                       (const char *)"CTExpChannel::abort");
    }
}
        
//+------------------------------------------------------------------
/**
 *	method:	CTExpChannel::dev_status
 *
 *	description:	method to execute "Status"
 *	This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *
 * @return	Status description
 *
 */
//+------------------------------------------------------------------
Tango::ConstDevString CTExpChannel::dev_status()
{
    Tango::ConstDevString	argout = DeviceImpl::dev_status();
    DEBUG_STREAM << "CTExpChannel::dev_status(): entering... !" << endl;

    //	Add your own code to control device here

    base_dev_status(argout);
    
    argout = tmp_status.c_str();
    return argout;
}

//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::set_state_from_group
// 
// description : 	Set the device state from the info gathered by a state
//					command on a group from which this motor is one of the element
//
//-----------------------------------------------------------------------------

void CTExpChannel::set_state_from_group(Controller::CtrlState &ci)
{
    set_state((Tango::DevState)ci.state);
    ctrl_str = ci.status;
}

}	//	namespace

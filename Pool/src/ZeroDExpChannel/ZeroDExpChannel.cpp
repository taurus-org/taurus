//+=============================================================================
//
// file :         ZeroDExpChannel.cpp
//
// description :  C++ source for the ZeroDExpChannel and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                ZeroDExpChannel are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author$
//
// $Revision$
//
// $Log$
// Revision 1.14  2007/09/07 16:23:46  tcoutinho
// safety commit
//
// Revision 1.13  2007/08/30 12:40:39  tcoutinho
// - changes to support Pseudo counters.
//
// Revision 1.12  2007/08/17 13:07:30  tcoutinho
// - pseudo motor restructure
// - pool base dev class restructure
// - initial commit for pseudo counters
//
// Revision 1.11  2007/07/26 07:05:42  tcoutinho
// fix bug 10 : Change all tango commands from Stop to Abort
//
// Revision 1.10  2007/05/30 14:51:19  etaurel
// - Add init of the i_am_dead data in the shared data area
// - Change the inform_ghost() method to propagate event only if the old
// state value is not MOVING
//
// Revision 1.9  2007/05/25 13:34:18  tcoutinho
// - fixes to state event propagation to the ghost group
//
// Revision 1.8  2007/05/22 13:43:09  tcoutinho
// - added new method
//
// Revision 1.7  2007/05/15 07:18:58  etaurel
// - Re-insert device in ghost group in case of Init command
//
// Revision 1.6  2007/05/11 08:43:56  tcoutinho
// - fixed bugs
//
// Revision 1.5  2007/05/10 09:32:34  etaurel
// - Small changes for better 64 bits portability
//
// Revision 1.4  2007/02/22 12:05:45  tcoutinho
// - added support for ghost measurement group
//
// Revision 1.3  2007/02/08 07:56:49  etaurel
// - Changes after compilation -Wall. Added the CumulatedValue attribute and
// everything to implement it (thread....)
//
// Revision 1.2  2007/01/30 16:42:21  etaurel
// - Fix bug in PoolBaseDev data member initialization
//
// Revision 1.1  2007/01/26 08:35:02  etaurel
// - We now have a first release of ZeroDController
//
//
// copyleft :   CELLS/ALBA
//		Edifici Ciences Nord
//		Campus Universitari de Bellaterra
//		Universitat Autonoma de Barcelona
//		08193 Bellaterra, Barcelona, SPAIN
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//=============================================================================



//===================================================================
//
//	The following table gives the correspondance
//	between commands and method's name.
//
//  Command's name|  Method's name
//	----------------------------------------
//  State   |  dev_state()
//  Status  |  dev_status()
//  Start   |  start()
//  Abort   |  abort()
//
//===================================================================


#include "CtrlFiCa.h"
#include <tango.h>
#include "Pool.h"
#include "PoolUtil.h"
#include "ZeroDExpChannel.h"
#include "ZeroDExpChannelClass.h"
#include "ZeroDExpChannelUtil.h"
#include "ZeroDThread.h"
#include "MeasurementGroup.h"

#include <pool/ZeroDCtrl.h>

#include <numeric>

namespace ZeroDExpChannel_ns
{

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::ZeroDExpChannel(string &s)
// 
// description : 	constructor for simulated ZeroDExpChannel
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
ZeroDExpChannel::ZeroDExpChannel(Tango::DeviceClass *cl,string &s)
:Pool_ns::PoolIndBaseDev(cl,s.c_str())
//:Tango::Device_4Impl(cl,s.c_str())
{
    init_cmd = false;
    init_device();
}

ZeroDExpChannel::ZeroDExpChannel(Tango::DeviceClass *cl,const char *s)
:Pool_ns::PoolIndBaseDev(cl,s)
//:Tango::Device_4Impl(cl,s)
{
    init_cmd = false;
    init_device();
}

ZeroDExpChannel::ZeroDExpChannel(Tango::DeviceClass *cl,const char *s,const char *d)
:Pool_ns::PoolIndBaseDev(cl,s,d)
//:Tango::Device_4Impl(cl,s,d)
{
    init_cmd = false;
    init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::delete_device()
{
    INFO_STREAM << "ZeroDExpChannel::delete_device() " << device_name << endl;
    //	Delete device's allocated object
    PoolIndBaseDev::delete_device();
    
//
// To know that we are executing this code due to a pool shutdown and not due to a
// "Init" command, we are using the polling thread ptr which is cleared in the DS
// shutdown sequence before the device destruction
//
    bool sd = false;

    Tango::Util *tg = Tango::Util::instance();
    if (tg->get_polling_thread_object() != NULL)
    {
        if (get_state() == Tango::MOVING)
        {
            TangoSys_OMemStream o;
            o << "Init command on 0D channel device is not allowed while a 0D channel is counting" << ends;

            Tango::Except::throw_exception((const char *)"ZeroDExp_InitNotAllowed",o.str(),
                    (const char *)"ZeroDExpChannel::delete_device");
        }
    }
    else
    {
        sd = true;
    }

    if (save_atts != NULL)
        delete save_atts;
    
//
// If we are not in a shutdown sequence:
// Lock the ghost group in order the polling thread not to
// start requesting for motor state while we are deleting it and
// inform ghost group that there is one channel less
//
// If we are called due to a Init command on the DServer admin,
// the measurement_group class is already deleted and the ghost group
// as well
//

    if (sd == false)
    {
        bool measurementgroup_class_deleted = false;
        MeasurementGroup_ns::MeasurementGroup *ghost_ptr;
        
        try
        {
            ghost_ptr = pool_dev->get_ghost_measurement_group_ptr();
        }
        catch (Tango::DevFailed &e)
        {
            measurementgroup_class_deleted = true;
        }
        
        if (measurementgroup_class_deleted == false)
        {
            Tango::AutoTangoMonitor atm(ghost_ptr);
            ghost_ptr->remove_channel_from_ghost_group(get_id());
        }
    }
                
//
// Delete the device from its controller and from the pool
//
    the_shared_data.read_values.clear();
    the_shared_data.acq_dates.clear();
    
    // If in shutdown mode, protect against exceptions
    if (sd)
    {
        try
        {
            delete_from_pool();
        }
        catch(Tango::DevFailed &df)
        {
            std::cout << "Error deleting '"<< get_name()
                      << "' from controller:" << std::endl;
            Tango::Except::print_exception(df);
        }
        catch(...)
        {
            std::cout << "Unknown error deleting '"<< get_name()
                      << "' from controller." << std::endl;
        }        
    }
    else
    {
        delete_from_pool();
    }
    delete_utils();
    
    PoolIndBaseDev::delete_device();
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::init_device()
{
    INFO_STREAM << "ZeroDExpChannel::ZeroDExpChannel() create device " << device_name << endl;

    // Initialise variables to default values
    //--------------------------------------------
    PoolIndBaseDev::init_device();

//
// Init some variables
//

    save_atts = NULL;
    read_value  = 0.0;
    cum_read_value = 0.0;
    cum_nb = 0;
    cum_err = 0;
    th = NULL;
    
    if (init_cmd == false)
    {
        attr_CumulationType_write = Pool_ns::AVERAGE;
        attr_CumulationTime_write = 0.0;
    }
    
    Tango::WAttribute &acq_att = dev_attr->get_w_attr_by_name("CumulationType");
    acq_att.set_write_value(static_cast<Tango::DevLong>(Pool_ns::AVERAGE));
        
    attr_Value_read = &read_value;
    attr_CumulatedValue_read = &cum_read_value;
    attr_CumulationType_read = &attr_CumulationType_write;
    attr_CumulatedPointsNumber_read = &cum_nb;
    attr_CumulatedPointsError_read = &cum_err;
    attr_CumulationTime_read = &attr_CumulationTime_write;
    
    the_shared_data.error_nb = 0;
    the_shared_data.cont_error = continueOnError;
    the_shared_data.stop_if_no_time = stopIfNoTime;
    the_shared_data.i_am_dead = false;
    
//
// We will push change event on State and Cumulated Value attributes
//

    Tango::Attribute &state_att = dev_attr->get_attr_by_name("state");
    state_att.set_change_event(true,false);
    
    Tango::Attribute &val_att = dev_attr->get_attr_by_name("CumulatedValue");
    val_att.set_change_event(true);
        
//
// Build the PoolBaseUtils class depending on the
// controller type
//

    set_utils(new ZeroDExpChannelUtil(pool_dev));
    
//
// Inform Pool of our birth
//

    Pool_ns::ZeroDExpChannelPool *zerod_pool_ptr = new Pool_ns::ZeroDExpChannelPool;
    init_pool_element(zerod_pool_ptr);
    
    
    
    {
        Tango::AutoTangoMonitor atm(pool_dev);
        pool_dev->add_element(zerod_pool_ptr);
    }

//
// Inform controller of our birth
//

    a_new_child(zerod_pool_ptr->get_ctrl_id());
    
//
// If we are called due to a init command, update our info in the
// ghost group
//
        
    if (init_cmd == true)
    {
        MeasurementGroup_ns::MeasurementGroup *ghost_ptr = pool_dev->get_ghost_measurement_group_ptr();
        {
            Tango::AutoTangoMonitor atm(ghost_ptr);
            ghost_ptr->add_zerod_to_ghost_group(get_id());
        }
        init_cmd = false;
    }
    
}

Pool_ns::ZeroDExpChannelPool &ZeroDExpChannel::get_zerod_element()
{
    return static_cast<Pool_ns::ZeroDExpChannelPool &>(get_pool_element());
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::get_device_property()
{
    //	Initialize your default values here (if not done with  POGO).
    //------------------------------------------------------------------
    PoolIndBaseDev::get_device_property();
    
    //	Read device properties from database.(Automatic code generation)
    //------------------------------------------------------------------
    Tango::DbData	dev_prop;
    dev_prop.push_back(Tango::DbDatum("StopIfNoTime"));
    dev_prop.push_back(Tango::DbDatum("ContinueOnError"));

    //	Call database and extract values
    //--------------------------------------------
    if (Tango::Util::instance()->_UseDb==true)
        get_db_device()->get_property(dev_prop);
    Tango::DbDatum	def_prop, cl_prop;
    ZeroDExpChannelClass	*ds_class =
        (static_cast<ZeroDExpChannelClass *>(get_device_class()));
    int	i = -1;

    //	Try to initialize StopIfNoTime from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  stopIfNoTime;
    //	Try to initialize StopIfNoTime from default device value
    def_prop = ds_class->get_default_device_property(dev_prop[i].name);
    if (def_prop.is_empty()==false)	def_prop  >>  stopIfNoTime;
    //	And try to extract StopIfNoTime value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  stopIfNoTime;

    //	Try to initialize ContinueOnError from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  continueOnError;
    //	Try to initialize ContinueOnError from default device value
    def_prop = ds_class->get_default_device_property(dev_prop[i].name);
    if (def_prop.is_empty()==false)	def_prop  >>  continueOnError;
    //	And try to extract ContinueOnError value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  continueOnError;



    //	End of Automatic code generation
    //------------------------------------------------------------------

}
//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::always_executed_hook()
{
    Tango::DevState old_state = get_state();
    
    if (old_state != Tango::MOVING)
    {
        bool th_dead;
        {
            omni_mutex_lock lo(the_mutex);
            th_dead = the_shared_data.i_am_dead;
        }

//
// If the thread is dead,reclaim its memory
//
    
        if ((th_dead == true) && (th != NULL))
        {
            void *ptr;
            th->join(&ptr);
            th = NULL;
        }
        
        base_always_executed_hook(false,false);
        Tango::DevState local_state = get_state();
        if ((local_state != Tango::ON) && 
            (local_state != Tango::FAULT) &&
            (local_state != Tango::UNKNOWN))
        {
            set_state(Tango::FAULT);
            unknown_state = true;
        }
    }
    
    inform_ghost(old_state,get_state());
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::inform_ghost
// 
// description : 	inform ghost group of a change in the state
//
//-----------------------------------------------------------------------------

void ZeroDExpChannel::inform_ghost(Tango::DevState old_state,Tango::DevState new_state)
{

    if (old_state != Tango::MOVING)
    {
        if(old_state != new_state && 
           new_state != Tango::ON &&
           new_state != Tango::MOVING)
        {
            try
            {
                MeasurementGroup_ns::MeasurementGroup *ghost = pool_dev->get_ghost_measurement_group_ptr();
                long idx = ghost->get_ind_elt_idx_from_id(get_id());
                Tango::AutoTangoMonitor synch(ghost);
                ghost->update_state_from_ctrls(idx,new_state);
            }
            catch(Tango::DevFailed &df)
            { /* if ghost is not yet created then no choice but to ignore this */ }
        }
    }
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_attr_hardware(vector<long> &attr_list)
{
    DEBUG_STREAM << "ZeroDExpChannel::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
    //	Add your own code here
}
//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_TimeBuffer
// 
// description : 	Extract real attribute values for TimeBuffer acquisition result.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_TimeBuffer(Tango::Attribute &attr)
{
    DEBUG_STREAM << "ZeroDExpChannel::read_TimeBuffer(Tango::Attribute &attr) entering... "<< endl;

    long len = the_shared_data.acq_dates.size();
    
    attr_TimeBuffer_read = new Tango::DevDouble[len];
    
    {
        omni_mutex_lock lo(the_mutex);
        vector<double>::iterator ite = the_shared_data.acq_dates.begin();
        long l = 0;
        for(;ite != the_shared_data.acq_dates.end();ite++)
        {
            attr_TimeBuffer_read[l++] = (*ite);
        }
    }
    
    attr.set_value(attr_TimeBuffer_read,len,0,true);
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_ValueBuffer
// 
// description : 	Extract real attribute values for ValueBuffer acquisition result.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_ValueBuffer(Tango::Attribute &attr)
{
    DEBUG_STREAM << "ZeroDExpChannel::read_ValueBuffer(Tango::Attribute &attr) entering... "<< endl;
    
    long len = the_shared_data.read_values.size();
    
    attr_ValueBuffer_read = new Tango::DevDouble[len];
    
    {
        omni_mutex_lock lo(the_mutex);
        vector<double>::iterator ite = the_shared_data.read_values.begin();
        long l = 0;
        for(;ite != the_shared_data.read_values.end();ite++)
        {
            attr_ValueBuffer_read[l++] = (*ite);
        }
    }
    
    attr.set_value(attr_ValueBuffer_read,len,0,true);
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_CumulationTime
// 
// description : 	Extract real attribute values for CumulationTime acquisition result.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_CumulationTime(Tango::Attribute &attr)
{
    DEBUG_STREAM << "ZeroDExpChannel::read_CumulationTime(Tango::Attribute &attr) entering... "<< endl;
    
    attr.set_value(attr_CumulationTime_read);
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::write_CumulationTime
// 
// description : 	Write CumulationTime attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::write_CumulationTime(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "ZeroDExpChannel::write_CumulationTime(Tango::WAttribute &attr) entering... "<< endl;
    
    Pool_ns::ZeroDExpChannelPool &zerod_element = get_zerod_element();
    
    double tmp_time;
    attr.get_write_value(tmp_time);
    
    if (tmp_time < 0.0)
    {
        Tango::Except::throw_exception((const char *)"ZeroDExpChannel_CantSetCumulationTime",
                                       (const char *)"The value you sent for the Cumulation Time is not valid. It cannot be negative",
                                        (const char *)"ZeroDExpChannel::write_CumulationTime");	
    }
    attr_CumulationTime_write = tmp_time;

//
// The CumulationTime attribute is a memorized attribute. If we are in simulatioin mode,
// reset the value stored in db to the value it had when the simulation mode
// was set to true
//
    
    if (zerod_element.get_simulation_mode())
    {
        try
        {
            Tango::DbDevice *db_dev = get_db_device();
            Tango::DbDatum off("__value");
            Tango::DbDatum att("CumulationTime");
            Tango::DbData db_data;

            short nb_att = 1;
            att << nb_att;
            off << save_atts->simu_time;
            db_data.push_back(att);
            db_data.push_back(off);
            db_dev->put_attribute_property(db_data);
        }
        catch (Tango::DevFailed &e)
        {
            Tango::Except::print_exception(e);
            throw;
        }
    }
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_CumulatedPointsNumber
// 
// description : 	Extract real attribute values for CumulatedPointsNumber acquisition result.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_CumulatedPointsNumber(Tango::Attribute &attr)
{
    DEBUG_STREAM << "ZeroDExpChannel::read_CumulatedPointsNumber(Tango::Attribute &attr) entering... "<< endl;

    Pool_ns::ZeroDExpChannelPool &zerod_element = get_zerod_element();
    
    if (!zerod_element.get_simulation_mode())
    {
        omni_mutex_lock lo(the_mutex);
        cum_nb = the_shared_data.read_values.size();
    }
    else
        cum_nb = 0;
        
    attr.set_value(attr_CumulatedPointsNumber_read);
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_CumulatedPointsError
// 
// description : 	Extract real attribute values for CumulatedPointsError acquisition result.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_CumulatedPointsError(Tango::Attribute &attr)
{
    DEBUG_STREAM << "ZeroDExpChannel::read_CumulatedPointsError(Tango::Attribute &attr) entering... "<< endl;

    Pool_ns::ZeroDExpChannelPool &zerod_element = get_zerod_element();
    
    if (!zerod_element.get_simulation_mode())
    {
        omni_mutex_lock lo(the_mutex);
        cum_err = the_shared_data.error_nb;
    }
    else
        cum_err = 0;
                
    attr.set_value(attr_CumulatedPointsError_read);
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_CumulationType
// 
// description : 	Extract real attribute values for CumulationType acquisition result.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_CumulationType(Tango::Attribute &attr)
{
    DEBUG_STREAM << "ZeroDExpChannel::read_CumulationType(Tango::Attribute &attr) entering... "<< endl;
    
    attr.set_value(attr_CumulationType_read);
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::write_CumulationType
// 
// description : 	Write CumulationType attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::write_CumulationType(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "ZeroDExpChannel::write_CumulationType(Tango::WAttribute &attr) entering... "<< endl;
    
    Pool_ns::ZeroDExpChannelPool &zerod_element = get_zerod_element();
    
    Tango::DevLong tmp_cum_type;
    attr.get_write_value(tmp_cum_type);

//
// Check input value
//

    if ((tmp_cum_type < 0) || (tmp_cum_type >= Pool_ns::numCumType ))
    {
        TangoSys_OMemStream o;
        o << "The value you sent for the Cumulation Type is not valid.";
        o << " It has to be a value between 0 and " << Pool_ns::numCumType - 1 << ends;
            
        Tango::Except::throw_exception((const char *)"ZeroDExpChannel_CantSetCumulationType",o.str(),
                                        (const char *)"ZeroDExpChannel::write_CumulationType");		
    }
    
    if (tmp_cum_type == Pool_ns::INTEGRAL)
    {
        Tango::Except::throw_exception((const char *)"ZeroDExpChannel_CantSetCumulationType",
                                       (const char *)"Sorry, the Integral cumulation type is not already implemented",
                                        (const char *)"ZeroDExpChannel::write_CumulationType");	
    }
    attr_CumulationType_write = tmp_cum_type;
    
//
// Do what we have to do according to the value sent
//

    switch(attr_CumulationType_write)
    {
        case Pool_ns::AVERAGE:
        cout << "Average cumulation type requested" << endl;
        break;
        
        case Pool_ns::SUM:
        cout << "Sum cumulation type requested" << endl;
        break;
        
        case Pool_ns::INTEGRAL:
        cout << "Integral cumulation type requested" << endl;
        break;
    }
    
//
// The CumulationType attribute is a memorized attribute. If we are in simulatioin mode,
// reset the value stored in db to the value it had when the simulation mode
// was set to true
//
    
    if (!zerod_element.get_simulation_mode())
    {
        try
        {
            Tango::DbDevice *db_dev = get_db_device();
            Tango::DbDatum off("__value");
            Tango::DbDatum att("CumulationType");
            Tango::DbData db_data;

            short nb_att = 1;
            att << nb_att;
            off << save_atts->simu_type;
            db_data.push_back(att);
            db_data.push_back(off);
            db_dev->put_attribute_property(db_data);
        }
        catch (Tango::DevFailed &e)
        {
            Tango::Except::print_exception(e);
            throw;
        }
    }
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_CumulatedValue
// 
// description : 	Extract real attribute values for CumulatedValue acquisition result.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_CumulatedValue(Tango::Attribute &attr)
{
    DEBUG_STREAM << "ZeroDExpChannel::read_CumulatedValue(Tango::Attribute &attr) entering... "<< endl;
    
    Pool_ns::ZeroDExpChannelPool &zerod_element = get_zerod_element();
    
    ShData local_data;

    if (attr_CumulationType_write == Pool_ns::NO_COMPUTATION)
    {
        Tango::Except::throw_exception((const char *)"ZeroDExpChannel_NoComputation",
          (const char *)"When CumulationType == NO_COMPUTATION it is not possible to read the CumulatedValue",
          (const char *)"ZeroDExpChannel::read_CumulatedValue");
    }

    if (!zerod_element.get_simulation_mode())
    {
            
//
// If we are acquring data, get values from the thread
//
    
        {
            omni_mutex_lock lo(the_mutex);
            local_data = the_shared_data;
        }
            
//
// Throw exception if the thread only gets error while reading the controller
//

        if (local_data.read_values.size() == 0)
        {
            if (local_data.error_nb != 0)
            {
                Tango::Except::throw_exception((const char *)"ZeroDExpChannel_BadController",
                  (const char *)"Up to now, it has not been possible to get any value from the device",
                  (const char *)"ZeroDExpChannel::read_CumulatedValue");
            }
            else
            {
                cum_read_value = 0.0;
            }
        }
        else
        {
            
//
// Compute value according to acquisition type
//

            switch (attr_CumulationType_write)
            {
                case Pool_ns::AVERAGE:
                cum_read_value = accumulate(local_data.read_values.begin(),local_data.read_values.end(),0.0);
                cum_read_value = cum_read_value / local_data.read_values.size();
                break;
            
                case Pool_ns::SUM:
                cum_read_value = accumulate(local_data.read_values.begin(),local_data.read_values.end(),0.0);
                break;
                
                case Pool_ns::ONE_SHOT:
                cum_read_value = local_data.read_values[0];
            }
        }
    }
    else
    {
        cum_read_value = 0.0;
    }
    
    attr.set_value(attr_CumulatedValue_read);

//
// Set attribuute quality factor
//
    
    if (get_state() == Tango::MOVING)
        attr.set_quality(Tango::ATTR_CHANGING);
    else
    {
        if (local_data.error_nb != 0)
            attr.set_quality(Tango::ATTR_ALARM);
    }
    DEBUG_STREAM << "ZeroDExpChannel::read_CumulatedValue(Tango::Attribute &attr) leaving ->" << *attr_CumulatedValue_read << endl;
}


//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_Value
// 
// description : 	Extract real attribute values for Value acquisition result.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_Value(Tango::Attribute &attr)
{
    DEBUG_STREAM << "ZeroDExpChannel::read_Value(Tango::Attribute &attr) entering... "<< endl;
    
    Pool_ns::ZeroDExpChannelPool &zerod_element = get_zerod_element();
    
    if (!zerod_element.get_simulation_mode())
    {
            
//
// If we are not acquiring data, returns the value coming from the controller
//

        Pool_ns::AutoPoolLock lo(fica_ptr->get_mon());
    
        try
        {
            ZeroDController *typed_ctrl = static_cast<ZeroDController *>(zerod_element.get_controller());
            
            typed_ctrl->PreReadAll();
            typed_ctrl->PreReadOne(get_axis());
            typed_ctrl->ReadAll();
            read_value = typed_ctrl->ReadOne(get_axis());
        }
        SAFE_CATCH(fica_ptr->get_name(),"read_Value");
        
        if (isnan(read_value) != 0)
        {
            Tango::Except::throw_exception((const char *)"ZeroDExpChannel_BadController",
                  (const char *)"The Zero D Exp Channel controller class has not re-defined method to read value (readOne(...))",
                  (const char *)"ZeroDExpChannel::read_Value");
        }
    }
    else
    {
        read_value = 0.0;
    }
    
    attr.set_value(attr_Value_read);
}

//+------------------------------------------------------------------
/**
 *	method:	ZeroDExpChannel::dev_status
 *
 *	description:	method to execute "Status"
 *	This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *
 * @return	Status description
 *
 */
//+------------------------------------------------------------------
Tango::ConstDevString ZeroDExpChannel::dev_status()
{
    Tango::ConstDevString	argout = DeviceImpl::dev_status();
    DEBUG_STREAM << "ZeroDExpChannel::dev_status(): entering... !" << endl;

    //	Add your own code to control device here

    base_dev_status(argout);

//
// Add a message for the acquisition type
//
    

    tmp_status = tmp_status + "\nThe data cumulation type is ";
    switch(attr_CumulationType_write)
    {
        case Pool_ns::AVERAGE:
        tmp_status = tmp_status +  "Average";
        break;
        
        case Pool_ns::SUM:
        tmp_status = tmp_status + "Sum";
        break;
        
        case Pool_ns::INTEGRAL:
        tmp_status = tmp_status + "Integral";
        break;
        
        case Pool_ns::NO_COMPUTATION:
        tmp_status = tmp_status + "No computation";
        break;

        case Pool_ns::ONE_SHOT:
        tmp_status = tmp_status + "One shot";
        break;
    }
    
    argout = tmp_status.c_str();
    return argout;
}

//+------------------------------------------------------------------
/**
 *	method:	ZeroDExpChannel::start
 *
 *	description:	method to execute "Start"
 *	Start acquiring data
 *
 *
 */
//+------------------------------------------------------------------
void ZeroDExpChannel::start()
{
    DEBUG_STREAM << "ZeroDExpChannel::start(): entering... !" << endl;

    //	Add your own code to control device here
    
    Pool_ns::ZeroDExpChannelPool &zerod_element = get_zerod_element();
    
    Tango::MultiAttribute *dev_attrs = get_device_attr();
    Tango::Attribute &cumval_att = dev_attrs->get_attr_by_name("CumulatedValue");
    Tango::Attribute &state_att = dev_attrs->get_attr_by_name("State");
        
    if (!zerod_element.get_simulation_mode())
    {
        
//
// Init shared memory
//

        the_shared_data.i_am_dead = false;
        the_shared_data.th_exit = false;
        the_shared_data.error_nb = 0;
        the_shared_data.cum_time = (long)(attr_CumulationTime_write * 1000);
        the_shared_data.cum_type = attr_CumulationType_write;
        the_shared_data.read_values.clear();
        the_shared_data.errors.length(0);
        the_shared_data.acq_dates.clear();
        the_shared_data.fire_event = pool_dev->zeroDNbReadPerEvent;
        the_shared_data.sleep_time.tv_sec = 0;
        the_shared_data.sleep_time.tv_nsec = pool_dev->zeroDThreadLoop_SleepTime * 1000000;
        
//
// Start acquisition thread
//
        
        th = new ZeroDThread(this,the_mutex,the_shared_data);
 
//
// Change state, clear CumulatedValue attribute quality factor and fire event
//

        set_state(Tango::MOVING);
    
        cumval_att.set_quality(Tango::ATTR_VALID);
        state_att.fire_change_event();
    }
    else
    {   
        set_state(Tango::MOVING);
        state_att.fire_change_event();
        
        set_state(Tango::ON);
        state_att.fire_change_event();
        
        if(attr_CumulationType_write != Pool_ns::NO_COMPUTATION)
        {
            read_CumulatedValue(cumval_att);
            cumval_att.fire_change_event();
        } 
    }
    DEBUG_STREAM << "ZeroDExpChannel::start(): leaving" << endl;
}

//+------------------------------------------------------------------
/**
 *	method:	ZeroDExpChannel::abort
 *
 *	description:	method to execute "Abort"
 *	Stop acquiring data
 *
 *
 */
//+------------------------------------------------------------------
void ZeroDExpChannel::abort()
{
    DEBUG_STREAM << "ZeroDExpChannel::stop(): entering... !" << endl;

    //	Add your own code to control device here
    base_abort(true);
}
//+------------------------------------------------------------------
/**
 *	method:	ZeroDExpChannel::base_abort
 *
 *	description:	method to execute "Abort"
 *	Stop acquiring data
 *
 *
 */
//+------------------------------------------------------------------
void ZeroDExpChannel::base_abort(bool send_evt)
{
//
// Do nothing if we are not acquiring
//

    if (th == NULL)
        return;
        
//
// Check if the thread is already dead
//

    bool th_dead;	
    {
        omni_mutex_lock lo(the_mutex);
        th_dead = the_shared_data.i_am_dead;
    }

//
// If the thread is not already dead, kill it
//
    
    if (th_dead == false)
    {
        {
            omni_mutex_lock lo(the_mutex);
            the_shared_data.th_exit = true;
        }
    }

    void *ptr;		
    th->join(&ptr);
    th = NULL;

//
// Change state and send event
    
    set_state(Tango::ON);
    
    if(send_evt)
    {
        Tango::MultiAttribute *dev_attrs = get_device_attr();
        Tango::Attribute &state_att = dev_attrs->get_attr_by_name("State");
        state_att.fire_change_event();
        
    //
    // Send event for the last Cumulated value
    //
    
        if(attr_CumulationType_write != Pool_ns::NO_COMPUTATION &&
           attr_CumulationType_write != Pool_ns::ONE_SHOT)
        {
            Tango::Attribute &cum_val_att = dev_attrs->get_attr_by_name("CumulatedValue");	
            read_CumulatedValue(cum_val_att);
            cum_val_att.fire_change_event();
        }
    }
}

ZeroDExpChannel::Simu_data::Simu_data(ZeroDExpChannel *chan):channel(chan)
{
    Tango::AutoTangoMonitor atm(channel);
    
    simu_time = channel->attr_CumulationTime_write;
    simu_type = channel->attr_CumulationType_write;
}

ZeroDExpChannel::Simu_data::~Simu_data()
{
    Tango::AutoTangoMonitor atm(channel);
    
    Tango::MultiAttribute *ma_ptr = channel->get_device_attr();
    
    if (channel->attr_CumulationTime_write != simu_time)
    {
        channel->attr_CumulationTime_write = simu_time;
        Tango::WAttribute &att = ma_ptr->get_w_attr_by_name("CumulationTime");
        att.set_write_value(simu_time);
    }
    
    if (channel->attr_CumulationType_write != simu_type)
    {
        channel->attr_CumulationType_write = simu_type;
        Tango::WAttribute &att = ma_ptr->get_w_attr_by_name("CumulationType");
        att.set_write_value(simu_type);
    }
}

}	//	namespace

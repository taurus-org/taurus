//=============================================================================
//
// file :        PseudoMotor.h
//
// description : Include for the PseudoMotor class.
//
// project :	Pseudo Motor
//
// $Author$
//
// $Revision$
//
// $Log$
// Revision 1.6  2007/08/30 12:40:39  tcoutinho
// - changes to support Pseudo counters.
//
// Revision 1.5  2007/08/23 10:33:42  tcoutinho
// - basic pseudo counter check
// - some fixes regarding pseudo motors
//
// Revision 1.4  2007/08/20 06:37:32  tcoutinho
// development commit
//
// Revision 1.3  2007/08/17 15:37:43  tcoutinho
// - fix bug: in case pseudo motor controller is in error
//
// Revision 1.2  2007/08/17 13:11:25  tcoutinho
// - pseudo motor restructure
// - pool base dev class restructure
// - initial commit for pseudo counters
//
// Revision 1.1  2007/08/14 07:58:47  tcoutinho
// New initial version of pseudo motor revised
//
//
// copyleft :    European Synchrotron Radiation Facility
//               BP 220, Grenoble 38043
//               FRANCE
//
//=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================
#ifndef _PSEUDOMOTOR_H
#define _PSEUDOMOTOR_H

#include <CtrlFiCa.h>
#include <PoolIndBaseDev.h>
#include <pool/PseudoMotCtrl.h>

namespace Pool_ns
{
class Pool;
class PseudoMotorPool;
}

/**
 * @author	$Author$
 * @version	$Revision$
 */

 //	Add your own constants definitions here.
 //-----------------------------------------------

/**
 * @namespace PseudoMotor_ns
 * @author tcoutinho
 * 
 * A namespace dedicated to pseudo motor related classes.
 * Automatically generated by pogo
 * 
 */
namespace PseudoMotor_ns
{

/**
 *  An abstractin level that translates a user meaninfull motor operation into
 * a real operation on motor(s).
 *  This is done through a pair of translation functions.
 *  Device States Description:
 *  Tango::ON :      All motors are ON
 *  Tango::ALARM :   At least one motor in the group is in ALARM state
 *  Tango::MOVING :  At least one of the motor in the group is MOVING
 *  Tango::FAULT :   At least one motor in the group is in FAULT mode
 */
class PseudoMotor: public Pool_ns::PoolIndBaseDev, public Pool_ns::IConstraintable
//class PseudoMotor: public Tango::Device_4Impl
{
public :
    //	Add your own data members here
    //-----------------------------------------

    
    //	Here is the Start of the automatic code generation part
    //-------------------------------------------------------------	
/**
 *	@name attributes
 *	Attributs member data.
 */
//@{
        Tango::DevDouble	*attr_Position_read;
        Tango::DevDouble	attr_Position_write;
//@}

/**
 *	@name Device properties
 *	Device properties member data.
 */
//@{
/**
 *	List of motors used by the pseudo motor
 */
    vector<Tango::DevLong> motor_list;
/**
 *	The motor group being used by this pseudo motor
 */
    Tango::DevLong  motor_group_id;
//@}

/**@name Constructors
 * Miscellaneous constructors */
//@{
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device Name
 */
    PseudoMotor(Tango::DeviceClass *cl,string &s);
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device Name
 */
    PseudoMotor(Tango::DeviceClass *cl,const char *s);
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device name
 *	@param d	Device description.
 */
    PseudoMotor(Tango::DeviceClass *cl,const char *s,const char *d);
//@}

/**@name Destructor
 * Only one desctructor is defined for this class */
//@{
/**
 * The object desctructor.
 */	
    ~PseudoMotor() {delete_device();};
/**
 *	will be called at device destruction or at init command.
 */
    void delete_device();
//@}

    
/**@name Miscellaneous methods */
//@{
/**
 *	Initialize the device
 */
    virtual void init_device();
/**
 *	Always executed method befor execution command method.
 */
    virtual void always_executed_hook();

//@}

/**
 * @name PseudoMotor methods prototypes
 */

//@{
/**
 *	Hardware acquisition for attributes.
 */
    virtual void read_attr_hardware(vector<long> &attr_list);
/**
 *	Extract real attribute values for Position acquisition result.
 */
    virtual void read_Position(Tango::Attribute &attr);
/**
 *	Write Position attribute values to hardware.
 */
    virtual void write_Position(Tango::WAttribute &attr);
/**
 *	Read/Write allowed for Position attribute.
 */
    virtual bool is_Position_allowed(Tango::AttReqType type);
/**
 *	Execution allowed for Abort command.
 */
    virtual bool is_Abort_allowed(const CORBA::Any &any);
/**
 *	Execution allowed for MoveRelative command.
 */
    virtual bool is_MoveRelative_allowed(const CORBA::Any &any);
/**
 * This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *	@return	State Code
 *	@exception DevFailed
 */
    virtual Tango::DevState	dev_state();
/**
 * This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *	@return	Status description
 *	@exception DevFailed
 */
    virtual Tango::ConstDevString	dev_status();
/**
 * Abort movement of all motors that are moving when the command is executed
 *	@exception DevFailed
 */
    void	abort();
/**
 * move relative command
 *	@param	argin	amount to move
 *	@exception DevFailed
 */
    void	move_relative(Tango::DevDouble);

/**
 *	Read the device properties from database
 */
    void get_device_property();
//@}

    //	Here is the end of the automatic code generation part
    //-------------------------------------------------------------	

    struct MotGroupMov
    {
        Tango::DeviceProxy		*mg_proxy;
        Tango::DevState			mg_state;
    };
    MotGroupMov					mov_mg;
    
    Tango::DevDouble get_last_position_set();
    
    inline MotGroupMov& get_motor_group_info()
    { return mov_mg; }

    virtual void base_abort(bool);
    
    inline void set_group_mov(bool val)
    { grp_mov = val; }
    
    inline void set_pseudo_motor_mov(bool val)
    { pm_mov = val; }
    
    inline PseudoMotorController *get_pm_ctrl() 
    { return static_cast<PseudoMotorController *>(get_controller()); }
    
    inline Pool_ns::PseudoMotCtrlFiCa *get_pm_fica_ptr()
    { return static_cast<Pool_ns::PseudoMotCtrlFiCa*>(fica_ptr); }

    double calc_pseudo(string &, double);
    double calc_pseudo(Pool_ns::ElementId, double);
    
    double get_value(bool cache = true);
    
    void pool_elem_changed(Pool_ns::PoolElemEventList &,
                           Pool_ns::PoolElementEvent &);

    virtual void init_pool_element(Pool_ns::PoolElement *);
    
    inline void set_siblings(vector<PseudoMotor*> &s)
    { siblings = s; }
    void set_siblings(map<int32_t, PseudoMotor*> &s);
    
    void sibling_died(int32_t role);
    
    /**
     * Fixes missing elements of the pseudo motor (like other pseudo motors)
     */
    void fix_pending_elements(Pool_ns::PseudoMotorPool *);
    
protected :
    //	Add your own data members here
    //-----------------------------------------
    
    bool                    last_set_pos_valid; ///< flag indicating if the pseudo motor position is to be considered from the last tango Set Position 
    bool                    grp_mov;            ///< set to true if the current movement is originated by the motor group
    bool                    pm_mov;	            ///< set to true if the current movement is originated by a pseudo motor in the pseudo motor system
    bool                    pm_mov_src;         ///< set to true if this pseudo motor is the one that originated the current movement
    
    vector<PseudoMotor*>	siblings;
    
    virtual void inform_ghost(Tango::DevState,Tango::DevState) {}
    
    void update_state(Tango::DevState *mg_state = NULL);
    
    int32_t get_motor_role(const std::string &);
    int32_t get_motor_role(Pool_ns::ElementId );
    
    inline void set_pseudo_motor_mov_src(bool val)
    {pm_mov_src = val;}
    
    void inform_siblings_pseudo_motor_mov(bool );
};

}	// namespace_ns

#endif	// _PSEUDOMOTOR_H

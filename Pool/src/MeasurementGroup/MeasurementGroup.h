//=============================================================================
//
// file :        MeasurementGroup.h
//
// description : Include for the MeasurementGroup class.
//
// project :	MeasurementGroup
//
// $Author$
//
// $Revision$
//
// $Log$
// Revision 1.29  2007/09/08 10:33:45  tcoutinho
// bug fixes
//
// Revision 1.28  2007/09/07 15:00:07  tcoutinho
// safety commit
//
// Revision 1.27  2007/08/30 12:40:39  tcoutinho
// - changes to support Pseudo counters.
//
// Revision 1.26  2007/08/24 15:55:26  tcoutinho
// safety weekend commit
//
// Revision 1.25  2007/08/17 13:07:29  tcoutinho
// - pseudo motor restructure
// - pool base dev class restructure
// - initial commit for pseudo counters
//
// Revision 1.24  2007/07/26 10:25:15  tcoutinho
// - Fix bug 1 :  Automatic temporary MotorGroup/MeasurementGroup deletion
//
// Revision 1.23  2007/07/26 07:05:42  tcoutinho
// fix bug 10 : Change all tango commands from Stop to Abort
//
// Revision 1.22  2007/07/24 07:11:06  tcoutinho
// fix bug: in data acquisition with a measurement it is necessary to check the state of the master channel in order to know when to stop all other channels
//
// Revision 1.21  2007/07/23 16:41:38  tcoutinho
// fix bug: Stop all channels when master stops during acquisition
//
// Revision 1.20  2007/06/26 12:34:20  tcoutinho
// fix bug with swapped channels
//
// Revision 1.19  2007/05/30 14:39:23  etaurel
// - init_cmd still defined in MeasurementGroup class while it is also defined
// in PoolBaseGroupDev class...
//
// Revision 1.18  2007/05/25 12:48:10  tcoutinho
// fix the same dead locks found on motor system to the acquisition system since release labeled for Josep Ribas
//
// Revision 1.17  2007/05/16 16:26:21  tcoutinho
// - fix dead lock
//
// Revision 1.16  2007/04/30 15:47:05  tcoutinho
// - new attribute "Channels"
// - new device property "Channel_List"
// - when add/remove channel, pool sends a change event on the MeasurementGroupList
//
// Revision 1.15  2007/04/23 15:17:59  tcoutinho
// - changes according to Sardana metting 26-03-2007: identical measurement groups can be created, Add/Remove  Exp. channel from a MG, etc
//
// Revision 1.14  2007/04/03 07:17:05  tcoutinho
// - following decision made on Sardana metting 26-03-2007, the save config feature will not be implemented on a measurement group basis.
//
// Revision 1.13  2007/04/03 07:07:13  tcoutinho
// - bug fix on 0D channels
//
// Revision 1.12  2007/03/02 16:33:11  tcoutinho
// - fix bugs - event related, attribute quality, etc
//
// Revision 1.11  2007/03/01 13:12:18  tcoutinho
// - measurement group event related fixes
//
// Revision 1.10  2007/02/28 16:21:52  tcoutinho
// - support for 0D channels
// - basic fixes after running first battery of tests on measurement group
//
// Revision 1.9  2007/02/22 11:56:22  tcoutinho
// - added support for ghost measurement group
// - added support for init/reload controller operations
// - fix some possible concurrency
// - added support for configuration (not finished)
//
// Revision 1.8  2007/02/16 10:01:16  tcoutinho
// - development checkin
//
// Revision 1.7  2007/02/13 14:39:42  tcoutinho
// - fix bug in motor group when a motor or controller are recreated due to an InitController command
//
// Revision 1.6  2007/02/08 16:18:13  tcoutinho
// - controller safety on PoolGroupBaseDev
//
// Revision 1.5  2007/02/07 16:53:05  tcoutinho
// safe guard commit
//
// Revision 1.4  2007/02/06 19:36:51  tcoutinho
// safe guard commit
//
// Revision 1.3  2007/02/06 19:11:23  tcoutinho
// safe guard commit
//
// Revision 1.2  2007/02/06 09:42:34  tcoutinho
// - safe development commit
//
// Revision 1.1  2007/02/03 15:20:39  tcoutinho
// - new Measurement Group Tango device
//
//
// copyleft :    European Synchrotron Radiation Facility
//               BP 220, Grenoble 38043
//               FRANCE
//
//=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================
#ifndef _MEASUREMENTGROUP_H
#define _MEASUREMENTGROUP_H

#include "PoolGroupBaseDev.h"
#include "CPoolDefs.h"

namespace Pool_ns
{
    class Pool;
    struct CTExpChannelPool;
    struct ZeroDExpChannelPool;
    struct OneDExpChannelPool;
    struct TwoDExpChannelPool;
    struct PseudoCounterPool;
    struct MotorPool;
    struct PseudoMotorPool;
    struct MeasurementGroupPool;
}

namespace CTExpChannel_ns
{
    class CTExpChannel;
}

namespace ZeroDExpChannel_ns
{
    class ZeroDExpChannel;
}

namespace OneDExpChannel_ns
{
    class OneDExpChannel;
}

namespace TwoDExpChannel_ns
{
    class TwoDExpChannel;
}

namespace PseudoCounter_ns
{
    class PseudoCounter;
}

namespace Motor_ns
{
    class Motor;
}

namespace PseudoMotor_ns
{
    class PseudoMotor;
}

/**
 * @author	$Author$
 * @version	$Revision$
 */

 //	Add your own constants definitions here.
 //-----------------------------------------------

class CoTiController;
class ZeroDController;
class OneDController;
class TwoDController;
class PseudoCounterController;
class MotorController;
class PseudoMotorController;

#define		DYN_ATTR_SUFIX		"_value"
#define		ALARM_STATUS_MSG	"The measurement group definition is not correct (No Timer/Monitor defined)"

/**
 * @namespace MeasurementGroup_ns
 *
 * @brief The namespace for the measurement group tango class.
 *
 * @author	tcoutinho
 */
namespace MeasurementGroup_ns
{

class MeasurementGroup;

/**
 * Class Description:
 * A Measurement Group Device used by the Sardana project device pool
 */

/*
 *	Device States Description:
*  Tango::ON :       The Measurement Group is ON and waiting
*  Tango::MOVING :   The Measurement Group is counting
*  Tango::FAULT :    A fault has been reported by the device controller of at least one of the elements
*  Tango::ALARM :    The MeasurementGroup configuration is not correct (No Timer/Monitor defined)
*  Tango::UNKNOWN :  An exception has been thrown when communicating with the components controllers.
 */


class MeasurementGroup: public Pool_ns::PoolGroupBaseDev
{
public :
    //	Add your own data members here
    //-----------------------------------------

    //	Here is the Start of the automatic code generation part
    //-------------------------------------------------------------
/**
 *	@name attributes
 *	Attributs member data.
 */
//@{
        Tango::DevLong	*attr_Integration_count_read;
        Tango::DevLong	attr_Integration_count_write;
        Tango::DevDouble	*attr_Integration_time_read;
        Tango::DevDouble	attr_Integration_time_write;
        Tango::DevString	*attr_Monitor_read;
        Tango::DevString	attr_Monitor_write;
        Tango::DevString	*attr_Timer_read;
        Tango::DevString	attr_Timer_write;
        Tango::DevString	*attr_ZeroDExpChannels_read;
        Tango::DevString	*attr_OneDExpChannels_read;
        Tango::DevString	*attr_TwoDExpChannels_read;
        Tango::DevString	*attr_Counters_read;
        Tango::DevString	*attr_Channels_read;
        Tango::DevString	*attr_PseudoCounters_read;
        Tango::DevString	*attr_Motors_read;
//@}

/**
 *	@name Device properties
 *	Device properties member data.
 */
//@{
/**
 *	List of user channels in this measurement group
 */
    std::vector<Tango::DevLong>	user_group_elt;
/**
 *	List of counter/timers in this measurement group
 */
    std::vector<Tango::DevLong>	ct_List;
/**
 *	List of 0D Experiment Channels in this measurement group
 */
    std::vector<Tango::DevLong>	zeroDExpChannel_List;
/**
 *	List of 1D Experiment Channels in this measurement group
 */
    std::vector<Tango::DevLong>	oneDExpChannel_List;
/**
 *	List of 2D Experiment Channels in this measurement group
 */
    std::vector<Tango::DevLong>	twoDExpChannel_List;
/**
 *	List of physical channels in this measurement group
 */
    std::vector<Tango::DevLong>	phys_group_elt;
/**
 *	list of pseudo counters in this measurement group
 */
    std::vector<Tango::DevLong>	pseudoCounter_List;
/**
 *	list of motors in this measurement group
 */
    std::vector<Tango::DevLong>	motor_List;
//@}

/**@name Constructors
 * Miscellaneous constructors */
//@{
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device Name
 */
    MeasurementGroup(Tango::DeviceClass *cl,string &s);
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device Name
 */
    MeasurementGroup(Tango::DeviceClass *cl,const char *s);
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device name
 *	@param d	Device description.
 */
    MeasurementGroup(Tango::DeviceClass *cl,const char *s,const char *d);
//@}

/**@name Destructor
 * Only one desctructor is defined for this class */
//@{
/**
 * The object desctructor.
 */
    ~MeasurementGroup() {delete_device();};
/**
 *	will be called at device destruction or at init command.
 */
    void delete_device();
//@}


/**@name Miscellaneous methods */
//@{
/**
 *	Initialize the device
 */
    virtual void init_device();
/**
 *	Always executed method befor execution command method.
 */
    virtual void always_executed_hook();

//@}

/**
 * @name MeasurementGroup methods prototypes
 */

//@{
/**
 *	Hardware acquisition for attributes.
 */
    virtual void read_attr_hardware(vector<long> &attr_list);
/**
 *	Extract real attribute values for Integration_count acquisition result.
 */
    virtual void read_Integration_count(Tango::Attribute &attr);
/**
 *	Write Integration_count attribute values to hardware.
 */
    virtual void write_Integration_count(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for Integration_time acquisition result.
 */
    virtual void read_Integration_time(Tango::Attribute &attr);
/**
 *	Write Integration_time attribute values to hardware.
 */
    virtual void write_Integration_time(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for Monitor acquisition result.
 */
    virtual void read_Monitor(Tango::Attribute &attr);
/**
 *	Write Monitor attribute values to hardware.
 */
    virtual void write_Monitor(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for Timer acquisition result.
 */
    virtual void read_Timer(Tango::Attribute &attr);
/**
 *	Write Timer attribute values to hardware.
 */
    virtual void write_Timer(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for ZeroDExpChannels acquisition result.
 */
    virtual void read_ZeroDExpChannels(Tango::Attribute &attr);
/**
 *	Extract real attribute values for OneDExpChannels acquisition result.
 */
    virtual void read_OneDExpChannels(Tango::Attribute &attr);
/**
 *	Extract real attribute values for TwoDExpChannels acquisition result.
 */
    virtual void read_TwoDExpChannels(Tango::Attribute &attr);
/**
 *	Extract real attribute values for Counters acquisition result.
 */
    virtual void read_Counters(Tango::Attribute &attr);
/**
 *	Extract real attribute values for Channels acquisition result.
 */
    virtual void read_Channels(Tango::Attribute &attr);
/**
 *	Extract real attribute values for PseudoCounters acquisition result.
 */
    virtual void read_PseudoCounters(Tango::Attribute &attr);
/**
 *	Extract real attribute values for Motor acquisition result.
 */
    virtual void read_Motors(Tango::Attribute &attr);    
/**
 *	Read/Write allowed for Integration_count attribute.
 */
    virtual bool is_Integration_count_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Integration_time attribute.
 */
    virtual bool is_Integration_time_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Monitor attribute.
 */
    virtual bool is_Monitor_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Timer attribute.
 */
    virtual bool is_Timer_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for ZeroDExpChannels attribute.
 */
    virtual bool is_ZeroDExpChannels_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for OneDExpChannels attribute.
 */
    virtual bool is_OneDExpChannels_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for TwoDExpChannels attribute.
 */
    virtual bool is_TwoDExpChannels_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Counters attribute.
 */
    virtual bool is_Counters_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Channels attribute.
 */
    virtual bool is_Channels_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for PseudoCounters attribute.
 */
    virtual bool is_PseudoCounters_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Motors attribute.
 */
    virtual bool is_Motors_allowed(Tango::AttReqType type);    
/**
 *	Execution allowed for Start command.
 */
    virtual bool is_Start_allowed(const CORBA::Any &any);
/**
 *	Execution allowed for Abort command.
 */
    virtual bool is_Abort_allowed(const CORBA::Any &any);
/**
 *	Execution allowed for AddExpChannel command.
 */
    virtual bool is_AddExpChannel_allowed(const CORBA::Any &any);
/**
 *	Execution allowed for RemoveExpChannel command.
 */
    virtual bool is_RemoveExpChannel_allowed(const CORBA::Any &any);
/**
 * This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *	@return	State Code
 *	@exception DevFailed
 */
    virtual Tango::DevState	dev_state();
/**
 * Start counting using the active configuration
 *	@exception DevFailed
 */
    void	start();
/**
 * Abort the acquisition
 *	@exception DevFailed
 */
    void	abort();
/**
 * Append a new experiment channel to the current list of channels in the measurement group.
 *	@param	argin	Experiment Channel name
 *	@exception DevFailed
 */
    void	add_exp_channel(Tango::DevString);
/**
 * Removes the experiment channel from the list of experiment channels in the measurement group
 *	@param	argin	Experiment channel name
 *	@exception DevFailed
 */
    void	remove_exp_channel(Tango::DevString);

/**
 *	Read the device properties from database
 */
     void get_device_property();
//@}

    //	Here is the end of the automatic code generation part
    //-------------------------------------------------------------

//
// Methods and data members for dynamic attributes
//

    void create_dyn_attr();
    void create_one_extra_attr(const std::string &, Pool_ns::ElementType, bool change_event = true);
    void remove_unwanted_dyn_attr_from_device();

    map<string,double*>		spectrum_data;
    map<string,double*>		image_data;

    bool is_ExtraAttr_allowed(Tango::AttReqType type);

    void read_CT_Attr(Tango::Attribute &attr);
    void read_0D_Attr(Tango::Attribute &attr);
    void read_1D_Attr(Tango::Attribute &attr);
    void read_2D_Attr(Tango::Attribute &attr);
    void read_PC_Attr(Tango::Attribute &attr);
    void read_MOT_Attr(Tango::Attribute &attr);

    void abort_all_channels(vector<Tango::DevFailed> &);

    ////////////////////////////////////////////////////
    // C O N T R O L L E R S
    ////////////////////////////////////////////////////

    /**
     * Generic Channel controller structure
     */
    struct ChCtrlInGrp : public Pool_ns::CtrlGrp
    {
        ChCtrlInGrp(Pool_ns::ControllerPool &ref,
                    Tango::Device_4Impl *dev = NULL):
            Pool_ns::CtrlGrp(ref, dev) {}
        virtual ~ChCtrlInGrp() {}

        virtual void PreReadAll() = 0;
        virtual void ReadAll() = 0;

    };

    /**
     * Pseudo counter controller structure
     */

    struct PseudoCoCtrlInGrp : public ChCtrlInGrp
    {
        PseudoCoCtrlInGrp(Pool_ns::ControllerPool &ref,
                          Tango::Device_4Impl *dev = NULL):
            ChCtrlInGrp(ref, dev) {}

        virtual ~PseudoCoCtrlInGrp() {}

        virtual void PreReadAll()		{ }
        virtual void ReadAll()			{ }

        PseudoCounterController *get_pc_ctrl();
    };

    /**
     * Counter/Timer controller structure
     */

    struct CTCtrlInGrp : public ChCtrlInGrp
    {
        CTCtrlInGrp(Pool_ns::ControllerPool &ref,
                    Tango::Device_4Impl *dev = NULL):
            ChCtrlInGrp(ref, dev) {}

        virtual ~CTCtrlInGrp() {}

        virtual void PreReadAll();
        virtual void ReadAll();

        CoTiController *get_ct_ctrl();
    };

    /**
     * 0D Experiment channel controller structure
     */
    struct ZeroDCtrlInGrp : public ChCtrlInGrp
    {
        ZeroDCtrlInGrp(Pool_ns::ControllerPool &ref,
                       Tango::Device_4Impl *dev = NULL):
            ChCtrlInGrp(ref, dev) {}

        virtual ~ZeroDCtrlInGrp() {}

        virtual void PreReadAll();
        virtual void ReadAll();

        ZeroDController *get_zerod_ctrl();
    };

    /**
     * 1D Experiment channel controller structure
     */
    struct OneDCtrlInGrp : public ChCtrlInGrp
    {
        OneDCtrlInGrp(Pool_ns::ControllerPool &ref,
                      Tango::Device_4Impl *dev = NULL):
            ChCtrlInGrp(ref, dev) {}

        virtual ~OneDCtrlInGrp() {}

        virtual void PreReadAll();
        virtual void ReadAll();

        OneDController *get_oned_ctrl();
    };

    /**
     * 2D Experiment channel controller structure
     */
    struct TwoDCtrlInGrp : public ChCtrlInGrp
    {
        TwoDCtrlInGrp(Pool_ns::ControllerPool &ref,
                      Tango::Device_4Impl *dev = NULL):
            ChCtrlInGrp(ref, dev) {}

        virtual ~TwoDCtrlInGrp() {}

        virtual void PreReadAll();
        virtual void ReadAll();

        TwoDController *get_twod_ctrl();
    };

    /**
     * Motor controller structure
     */
    struct MotorCtrlInGrp : public ChCtrlInGrp
    {
        MotorCtrlInGrp(Pool_ns::ControllerPool &ref,
                       Tango::Device_4Impl *dev = NULL):
            ChCtrlInGrp(ref, dev) {}

        virtual ~MotorCtrlInGrp() {}

        virtual void PreReadAll();
        virtual void ReadAll();

        virtual MotorController *get_motor_ctrl();
    };
    
    /**
     * Pseudo Motor controller structure
     */
    struct PseudoMotorCtrlInGrp : public MotorCtrlInGrp
    {
        PseudoMotorCtrlInGrp(Pool_ns::ControllerPool &ref,
                       Tango::Device_4Impl *dev = NULL):
            MotorCtrlInGrp(ref, dev) {}

        virtual ~PseudoMotorCtrlInGrp() {}

        virtual void PreReadAll() {}
        virtual void ReadAll() {}
        
        virtual MotorController *get_motor_ctrl();
        PseudoMotorController *get_pseudo_motor_ctrl();
    };    
    
    
    ////////////////////////////////////////////////////
    // C H A N N E L S
    ////////////////////////////////////////////////////

    /**
     * Generic Channel structure
     */
    struct ChInGrp: public Pool_ns::IndEltGrp
    {
        int32_t attr_idx;

        virtual Pool_ns::MntGrpEltType get_type() = 0;

        ChInGrp(Pool_ns::PoolElement &ref, Pool_ns::CtrlGrp *ctrl_ptr, 
                Tango::Device_4Impl *device, Pool_ns::ElementId grp,
                Tango::Device_4Impl *logger = NULL):
            Pool_ns::IndEltGrp(ref, ctrl_ptr, device, grp, logger),
            attr_idx(-1) {}
        virtual ~ChInGrp() {}

        virtual void PreReadOne() = 0;
        virtual void ReadOne() = 0;
    };

    /**
     * A generic channel structure representing a single value channel.
     * This is useful to provide a common super class for counter/timer, 0D and
     * pseudo counter channels
     */
    struct SingleValChInGrp: public ChInGrp
    {
        double value;

        vector<SingleValChInGrp*> used_by;	///< counters that use this counter
        vector<SingleValChInGrp*> uses;		///< counters that are used by this counter

        SingleValChInGrp(Pool_ns::PoolElement &ref, Pool_ns::CtrlGrp *ctrl_ptr, 
                         Tango::Device_4Impl *device, Pool_ns::ElementId grp,
                         Tango::Device_4Impl *logger = NULL):
            ChInGrp(ref, ctrl_ptr, device, grp, logger) {}
        virtual ~SingleValChInGrp() {}
    };

    /**
     * Counter/Timer Channel structure
     */
    struct CTInGrp: public SingleValChInGrp
    {
        CTInGrp(Pool_ns::CTExpChannelPool &ref, Pool_ns::CtrlGrp *ctrl_ptr,
                Tango::Device_4Impl *device, Pool_ns::ElementId grp, 
                Tango::Device_4Impl *logger = NULL);
        virtual ~CTInGrp() {}

        virtual const char *get_family();
        virtual Pool_ns::MntGrpEltType get_type();

        virtual void PreReadOne();
        virtual void ReadOne();

        Pool_ns::CTExpChannelPool &get_ct();
        CTExpChannel_ns::CTExpChannel *get_countertimer_device();
    };

    /**
     * 0D Experiment Channel structure
     */
    struct ZeroDInGrp: public SingleValChInGrp
    {
        ZeroDInGrp(Pool_ns::ZeroDExpChannelPool &ref, Pool_ns::CtrlGrp *ctrl_ptr, 
                   Tango::Device_4Impl *device, Pool_ns::ElementId grp,
                   Tango::Device_4Impl *logger = NULL);
        virtual ~ZeroDInGrp() {}

        virtual const char *get_family();
        virtual Pool_ns::MntGrpEltType get_type();

        virtual void PreReadOne();
        virtual void ReadOne();

        Pool_ns::ZeroDExpChannelPool &get_zerod();
        ZeroDExpChannel_ns::ZeroDExpChannel *get_zerod_device();
    };

    /**
     * 1D Experiment Channel structure
     */
    struct OneDInGrp: public ChInGrp
    {
        double value[10000];

        Tango::DevLong data_length;

        OneDInGrp(Pool_ns::OneDExpChannelPool &ref, Pool_ns::CtrlGrp *ctrl_ptr, 
                  Tango::Device_4Impl *device, Pool_ns::ElementId grp,
                  Tango::Device_4Impl *logger = NULL);
        virtual ~OneDInGrp() {}
        
        virtual const char *get_family();
        virtual Pool_ns::MntGrpEltType get_type();
        
        virtual void PreReadOne();
        virtual void ReadOne();
        
        Pool_ns::OneDExpChannelPool &get_oned();
        OneDExpChannel_ns::OneDExpChannel *get_oned_device();
    };
    

    /**
     * Pseudo Counter Channel structure
     */
    struct PseudoCoInGrp: public SingleValChInGrp
    {
        vector<CTInGrp*>		uses_ct;	///< all counter/timers that needed by this pseudo
        vector<ZeroDInGrp*>		uses_0D;	///< all 0Ds that are needed by this pseudo
        vector<OneDInGrp*>      uses_1D;     ///< all 1Ds that are needed by this pseudo
        vector<PseudoCoInGrp*>	uses_pc;	///< all pseudos that are needed by this pseudo
        bool					is_virtual;	///< true if it does not need any channel

        PseudoCoInGrp(Pool_ns::PseudoCounterPool &ref, Pool_ns::CtrlGrp *ctrl_ptr, 
                      Tango::Device_4Impl *device, Pool_ns::ElementId grp,
                      Tango::Device_4Impl *logger = NULL);
        virtual ~PseudoCoInGrp() {}

        virtual const char *get_family();
        virtual Pool_ns::MntGrpEltType get_type();

        virtual void PreReadOne();
        virtual void ReadOne();

        Pool_ns::PseudoCounterPool &get_pc();
        PseudoCounter_ns::PseudoCounter *get_pseudo_counter_device();
    };

    /**
     * 2D Experiment Channel structure
     */
    struct TwoDInGrp: public ChInGrp
    {
        double value[4000000];

        Tango::DevLong xdim;
        Tango::DevLong ydim;

        TwoDInGrp(Pool_ns::TwoDExpChannelPool &ref, Pool_ns::CtrlGrp *ctrl_ptr, 
                  Tango::Device_4Impl *device, Pool_ns::ElementId grp,
                  Tango::Device_4Impl *logger = NULL);

        virtual ~TwoDInGrp() {}

        virtual const char *get_family();
        virtual Pool_ns::MntGrpEltType get_type();

        virtual void PreReadOne();
        virtual void ReadOne();

      
        Pool_ns::TwoDExpChannelPool &get_twod();
        TwoDExpChannel_ns::TwoDExpChannel *get_twod_device();
    };

    struct MotorInGrp: public SingleValChInGrp
    {
        MotorInGrp(Pool_ns::PoolElement &ref, Pool_ns::CtrlGrp *ctrl_ptr,
                   Tango::Device_4Impl *device, Pool_ns::ElementId grp, 
                   Tango::Device_4Impl *logger = NULL);
        virtual ~MotorInGrp() {}

        virtual const char *get_family();
        virtual Pool_ns::MntGrpEltType get_type();

        virtual void PreReadOne();
        virtual void ReadOne();

        virtual Pool_ns::MotorPool &get_motor();
        Motor_ns::Motor *get_motor_device();
    };
    
    struct PseudoMotorInGrp: public MotorInGrp
    {
        PseudoMotorInGrp(Pool_ns::PoolElement &ref, Pool_ns::CtrlGrp *ctrl_ptr,
                         Tango::Device_4Impl *device, Pool_ns::ElementId grp, 
                         Tango::Device_4Impl *logger = NULL);
        virtual ~PseudoMotorInGrp() {}

        virtual const char *get_family();

        virtual void PreReadOne() {}
        virtual void ReadOne();
        
        virtual Pool_ns::MotorPool &get_motor();
        Pool_ns::PseudoMotorPool &get_pseudo_motor();     
        PseudoMotor_ns::PseudoMotor *get_pseudo_motor_device();
    };    
    
protected :
    //	Add your own data members here
    //-----------------------------------------

    vector<PseudoCoInGrp*>			pseudo_elts;
    vector<PseudoCoCtrlInGrp*> 		implied_pseudo_ctrls;
    int32_t							ct_nb;
    int32_t							zeroD_nb;
    int32_t							oneD_nb;
    int32_t							twoD_nb;
    int32_t							pc_nb;
    int32_t                         mot_nb;
    
    Pool_ns::AquisitionMode			aq_mode;
    string							timer;
    string							monitor;
    ChInGrp							*master;

    bool							first_write_timer;
    bool							first_write_monitor;
    bool							first_write_integration_time;
    bool							first_write_integration_count;

/**
 * Map with key = tango attribute index; value = correponding experiment channel
 */
    map<int32_t, ChInGrp*> attr_channel_map;
    map<string, ChInGrp*> attr_name_channel_map;

    virtual void init_pool_element(Pool_ns::PoolElement *);
    virtual void State_all_ind(vector<Controller *> &);
    virtual void State_ctrl_ind(Pool_ns::CtrlGrp *ctrl_grp, vector<Controller *> &);
    virtual void handle_temporary_siblings();

    CTInGrp &get_ct_from_index(int32_t);
    ZeroDInGrp &get_zerod_from_index(int32_t);
    OneDInGrp &get_oned_from_index(int32_t);
    TwoDInGrp &get_twod_from_index(int32_t);
    PseudoCoInGrp &get_pc_from_index(int32_t);
    MotorInGrp &get_motor_from_index(int32_t);
    
    CTInGrp *build_ct(Pool_ns::CTExpChannelPool &);
    ZeroDInGrp *build_zerod(Pool_ns::ZeroDExpChannelPool &);
    OneDInGrp *build_oned(Pool_ns::OneDExpChannelPool &);
    TwoDInGrp *build_twod(Pool_ns::TwoDExpChannelPool &);
    PseudoCoInGrp *build_pc(Pool_ns::PseudoCounterPool &);
    MotorInGrp *build_motor(Pool_ns::MotorPool &);
    PseudoMotorInGrp *build_pm(Pool_ns::PseudoMotorPool &);
    
    CTCtrlInGrp *build_ct_ctrl(Pool_ns::ControllerPool &);
    ZeroDCtrlInGrp *build_zerod_ctrl(Pool_ns::ControllerPool &);
    OneDCtrlInGrp *build_oned_ctrl(Pool_ns::ControllerPool &);
    TwoDCtrlInGrp *build_twod_ctrl(Pool_ns::ControllerPool &);
    PseudoCoCtrlInGrp *build_pc_ctrl(Pool_ns::ControllerPool &);
    MotorCtrlInGrp *build_motor_ctrl(Pool_ns::ControllerPool &);
    PseudoMotorCtrlInGrp *build_pm_ctrl(Pool_ns::ControllerPool &);
    
    void get_limits(Pool_ns::MntGrpEltType,int32_t &,int32_t &);

    template<class LongIterator> void read_ct_values_from_ctrls(LongIterator, LongIterator );
    template<class LongIterator> void read_zerod_values_from_ctrls(LongIterator, LongIterator );
    template<class LongIterator> void read_oned_values_from_ctrls(LongIterator, LongIterator );
    template<class LongIterator> void read_twod_values_from_ctrls(LongIterator, LongIterator );
    template<class LongIterator> void read_pc_values_from_ctrls(LongIterator, LongIterator );
    template<class LongIterator> void read_motor_values_from_ctrls(LongIterator, LongIterator );
    
    void update_attr2channel_indexes();

    void write_list_props_to_db(string &, std::vector<Tango::DevLong> &);

    bool is_elem_only_used_in_pc(PseudoCoInGrp *, SingleValChInGrp *);

public:
    
    CTInGrp &get_ct_from_name(const string &);
    ZeroDInGrp &get_zerod_from_name(const string &);
    OneDInGrp &get_oned_from_name(const string &);
    TwoDInGrp &get_twod_from_name(const string &);
    PseudoCoInGrp &get_pc_from_name(const string &);
    MotorInGrp &get_motor_from_name(const string &);
    PseudoMotorInGrp &get_pm_from_name(const string &);
    
    PseudoCoInGrp &get_pc_from_id(Pool_ns::ElementId );

    ChInGrp &get_channel_from_name(const std::string &);
    ChInGrp &get_channel_from_id(Pool_ns::ElementId ch_id, Pool_ns::ElementType type)
    {
        try { return static_cast<ChInGrp&>(get_ind_elt_from_id(ch_id, type)); }
        catch(Tango::DevFailed &e) { return get_pc_from_id(ch_id); }
    }

    Tango::DevDouble *get_ct_data_from_index(int32_t );

    PseudoCoCtrlInGrp &get_pc_ctrl_grp_from_id(Pool_ns::ElementId, int32_t &);

    void read_master();
    void read_values(Pool_ns::MntGrpEltType type = Pool_ns::ANY_CHANNEL);

    virtual void build_grp();
    virtual Pool_ns::PoolElement &get_pool_obj();
    
    virtual void base_abort(bool);

    void update_state_from_ctrls(int32_t idx = -1, Tango::DevState state = Tango::ON);

    virtual void pool_elem_changed(Pool_ns::PoolElemEventList &evt,Pool_ns::PoolElementEvent &);

    void add_ct_to_ghost_group(Pool_ns::ElementId);
    void add_zerod_to_ghost_group(Pool_ns::ElementId);
    void add_oned_to_ghost_group(Pool_ns::ElementId);
    void add_twod_to_ghost_group(Pool_ns::ElementId);

    void remove_channel_from_ghost_group(Pool_ns::ElementId);
    
    Pool_ns::MeasurementGroupPool &get_measurement_group_obj();
};

class GhostMeasurementGroup : public MeasurementGroup
{
public:

    GhostMeasurementGroup(Tango::DeviceClass *cl,string &s)
    :MeasurementGroup(cl, s) {}

    GhostMeasurementGroup(Tango::DeviceClass *cl,const char *s)
    :MeasurementGroup(cl, s) {}

    GhostMeasurementGroup(Tango::DeviceClass *cl,const char *s,const char *d)
    :MeasurementGroup(cl, s, d) {}
    
protected:
    
//    virtual void read_state_from_ctrls() 
//    { read_state_from_ctrls_lockone(); }
};

/**
 * Class Description: A Double, read only, scalar attribute
 *
 */
class Dou_CT_R_Attrib: public Tango::Attr
{
public:
    Dou_CT_R_Attrib(string &name):Attr(name.c_str(), Tango::DEV_DOUBLE, Tango::READ) {};
    ~Dou_CT_R_Attrib() {};


    virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
    {(static_cast<MeasurementGroup *>(dev))->read_CT_Attr(att);}
    virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
    {return (static_cast<MeasurementGroup *>(dev))->is_ExtraAttr_allowed(ty);}
};

/**
 * Class Description: A Double, read only, scalar attribute
 *
 */
class Dou_PC_R_Attrib: public Tango::Attr
{
public:
    Dou_PC_R_Attrib(string &name):Attr(name.c_str(), Tango::DEV_DOUBLE, Tango::READ) {};
    ~Dou_PC_R_Attrib() {};


    virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
    {(static_cast<MeasurementGroup *>(dev))->read_PC_Attr(att);}
    virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
    {return (static_cast<MeasurementGroup *>(dev))->is_ExtraAttr_allowed(ty);}
};

/**
 * Class Description: A Double, read only, scalar attribute
 *
 */
class Dou_R_Scl_Attrib: public Tango::Attr
{
public:
    Dou_R_Scl_Attrib(string &name):Attr(name.c_str(), Tango::DEV_DOUBLE, Tango::READ){};
    ~Dou_R_Scl_Attrib() {};

    virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
    {(static_cast<MeasurementGroup *>(dev))->read_0D_Attr(att);}
    virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
    {return (static_cast<MeasurementGroup *>(dev))->is_ExtraAttr_allowed(ty);}
};

/**
 * Class Description: A Double, read only, scalar attribute
 *
 */
class Dou_MOT_R_Attrib: public Tango::Attr
{
public:
    Dou_MOT_R_Attrib(string &name):Attr(name.c_str(), Tango::DEV_DOUBLE, Tango::READ) {};
    ~Dou_MOT_R_Attrib() {};


    virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
    {(static_cast<MeasurementGroup *>(dev))->read_MOT_Attr(att);}
    virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
    {return (static_cast<MeasurementGroup *>(dev))->is_ExtraAttr_allowed(ty);}
};

/**
 * Class Description: A Double, read only, spectrum attribute
 *
 */
class Dou_R_Sptrm_Attrib: public Tango::SpectrumAttr
{
public:
    Dou_R_Sptrm_Attrib(string &name, long max_x):SpectrumAttr(name.c_str(), Tango::DEV_DOUBLE, Tango::READ, max_x){};
    ~Dou_R_Sptrm_Attrib() {};

    virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
    {(static_cast<MeasurementGroup *>(dev))->read_1D_Attr(att);}
    virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
    {return (static_cast<MeasurementGroup *>(dev))->is_ExtraAttr_allowed(ty);}
};

/**
 * Class Description: A Double, read only, image attribute
 *
 */
class Dou_R_Img_Attrib: public Tango::ImageAttr
{
public:
    Dou_R_Img_Attrib(string &name, long max_x, long max_y):ImageAttr(name.c_str(), Tango::DEV_DOUBLE, Tango::READ, max_x, max_y){};
    ~Dou_R_Img_Attrib() {};

    virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
    {(static_cast<MeasurementGroup *>(dev))->read_2D_Attr(att);}
    virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
    {return (static_cast<MeasurementGroup *>(dev))->is_ExtraAttr_allowed(ty);}
};

}	// namespace_ns

#endif	// _MEASUREMENTGROUP_H

//+=============================================================================
//
// file :         PseudoCounter.cpp
//
// description :  C++ source for the PseudoCounter and its commands.
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                PseudoCounter are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author$
//
// $Revision$
//
// $Log$
// Revision 1.5  2007/08/30 12:40:39  tcoutinho
// - changes to support Pseudo counters.
//
// Revision 1.4  2007/08/24 15:55:54  tcoutinho
// safety weekend commit
//
// Revision 1.3  2007/08/23 10:33:42  tcoutinho
// - basic pseudo counter check
// - some fixes regarding pseudo motors
//
// Revision 1.2  2007/08/20 06:37:31  tcoutinho
// development commit
//
// Revision 1.1  2007/08/17 13:11:04  tcoutinho
// - pseudo motor restructure
// - pool base dev class restructure
// - initial commit for pseudo counters
//
//
// copyleft :     European Synchrotron Radiation Facility
//                BP 220, Grenoble 38043
//                FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondance
//	between commands and method's name.
//
//  Command's name|  Method's name
//	----------------------------------------
//  State   |  dev_state()
//  Status  |  dev_status()
//  Start   |  start()
//  Abort   |  abort()
//
//===================================================================

#include "PseudoCounter.h"
#include "PseudoCounterClass.h"
#include "PseudoCounterUtil.h"
#include "PoolUtil.h"

#include <pool/PseudoCoCtrl.h>
#include <tango.h>

namespace PseudoCounter_ns
{

template<class T>
inline void PRINT_ELEMENTS(const T& coll, const char* optcstr="")
{
    typename T::const_iterator pos;
    cout << optcstr;
    for(pos = coll.begin(); pos != coll.end() ; pos++)
        cout << *pos << ' ';
    cout << endl;
}

//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::PseudoCounter(string &s)
//
// description : 	constructor for simulated PseudoCounter
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name
//
//-----------------------------------------------------------------------------
PseudoCounter::PseudoCounter(Tango::DeviceClass *cl,string &s)
//:Tango::Device_4Impl(cl,s.c_str())
:Pool_ns::PoolIndBaseDev(cl,s.c_str())
{
    init_cmd = false;
    init_device();
}

PseudoCounter::PseudoCounter(Tango::DeviceClass *cl,const char *s)
//:Tango::Device_4Impl(cl,s)
:Pool_ns::PoolIndBaseDev(cl,s)
{
    init_cmd = false;
    init_device();
}

PseudoCounter::PseudoCounter(Tango::DeviceClass *cl,const char *s,const char *d)
//:Tango::Device_4Impl(cl,s,d)
:Pool_ns::PoolIndBaseDev(cl,s,d)
{
    init_cmd = false;
    init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::delete_device()
//
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void PseudoCounter::delete_device()
{
    //	Delete device's allocated object
//
// A trick to inform client(s) listening on events that the pool device is down.
// Without this trick, the clients will have to wait for 3 seconds before being informed
// This is the Tango device time-out.
// To know that we are executing this code due to a pool shutdown and not due to a
// "Init" command, we are using the polling thread ptr which is cleared in the DS
// shutdown sequence before the device destruction
//

    bool sd = false;

    Tango::Util *tg = Tango::Util::instance();
    if (tg->get_polling_thread_object() == NULL)
    {
        sd = true;
    }

    for(vector<string>::size_type ul = 0; ul < channel_list.size(); ul++)
        if (ch_mov[ul].proxy != NULL) delete ch_mov[ul].proxy;
    delete [] ch_mov;

    if(sd == true)
    {
        SAFE_DELETE_ARRAY(attr_ChannelList_read);
    }
//
// Delete the device from its controller and from the pool
//
    delete_from_pool();
    delete_utils();
    
    PoolIndBaseDev::delete_device();
}

//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::init_device()
//
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void PseudoCounter::init_device()
{
    INFO_STREAM << "PseudoCounter::PseudoCounter() create device " << device_name << endl;

    // Initialise variables to default values
    //--------------------------------------------
    PoolIndBaseDev::init_device();
    
    if (!init_cmd)
    {
        vector<string>::size_type ch_nb = channel_list.size();
        attr_ChannelList_read = new Tango::DevString[ch_nb];
        ch_values.resize(ch_nb,0.0);
    }

    attr_Value_read = &value;

//
// We will push change event on State and value attributes
//
    Tango::Attribute &state_att = dev_attr->get_attr_by_name("state");
    state_att.set_change_event(true,false);

    Tango::Attribute &val_att = dev_attr->get_attr_by_name("Value");
    val_att.set_change_event(true);

//
// Build the PoolBaseUtils class depending on the
// controller type
//

    set_utils(new PseudoCounterUtil(pool_dev));

//
// Inform Pool of our birth
//

    Pool_ns::PseudoCounterPool *pc_pool_ptr = new Pool_ns::PseudoCounterPool;
    init_pool_element(pc_pool_ptr);

    {
        Tango::AutoTangoMonitor atm(pool_dev);
        pool_dev->add_element(pc_pool_ptr);
    }

//
// Inform controller of our birth
//

    if (is_fica_built())
    {
        a_new_child(pc_pool_ptr->get_ctrl_id());
    }
    else
        set_state(Tango::FAULT);

    ch_mov = new ChannelMov[channel_list.size()];
    for(vector<string>::size_type ul = 0; ul < channel_list.size(); ul++)
    {
        try
        {
            Pool_ns::CTExpChannelPool &ctp =
                pool_dev->get_countertimer(channel_list[ul]);
            ch_mov[ul].type = COUNTER_TIMER;
            ch_mov[ul].id = ctp.id;
            ch_mov[ul].proxy = new Tango::DeviceProxy(ctp.get_full_name().c_str());
            continue;
        }
        catch(Tango::DevFailed &e)
        {}

        try
        {
            Pool_ns::ZeroDExpChannelPool &zdp =
                pool_dev->get_zerod(channel_list[ul]);
            ch_mov[ul].type = ZEROD;
            ch_mov[ul].id = zdp.id;
            ch_mov[ul].proxy = new Tango::DeviceProxy(zdp.get_full_name().c_str());
            continue;
        }
        catch(Tango::DevFailed &e)
        {}

        try
        {
            Pool_ns::PseudoCounterPool &pcp =
                pool_dev->get_pseudo_counter(channel_list[ul]);
            ch_mov[ul].type = PSEUDO_COUNTER;
            ch_mov[ul].id = pcp.id;
            ch_mov[ul].proxy = new Tango::DeviceProxy(pcp.get_full_name().c_str());
            continue;
        }
        catch(Tango::DevFailed &e)
        {}
    }
}

void PseudoCounter::init_pool_element(Pool_ns::PoolElement *pe)
{
    PoolIndBaseDev::init_pool_element(pe);

    Pool_ns::PseudoCounterPool *pcp =
        static_cast<Pool_ns::PseudoCounterPool *>(pe);

    Tango::AutoTangoMonitor atm(pool_dev);

    vector<string>::size_type ul = 0;
    vector<string>::size_type co_nb = channel_list.size();
    vector<Tango::DevLong>::iterator ch_id_ite = channel_list.begin();
    for(;ch_id_ite != channel_list.end() ; ch_id_ite++)
    {
        Pool_ns::ElementId ch_id = (Pool_ns::ElementId)*ch_id_ite;
        Pool_ns::PoolElement *ch_ptr = NULL;
        try
        {
            Pool_ns::CTExpChannelPool &ctp =
                                pool_dev->get_countertimer(ch_id);
            ch_ptr = &ctp;
            pcp->ch_elts.push_back(ch_id);
        }
        catch(Tango::DevFailed &e)
        {}

        if(!ch_ptr)
        {
            try
            {
                Pool_ns::ZeroDExpChannelPool &zdp =
                                pool_dev->get_zerod(ch_id);
                ch_ptr = &zdp;
                pcp->ch_elts.push_back(ch_id);
            }
            catch(Tango::DevFailed &e)
            {}
        }

        if(!ch_ptr)
        {
            try
            {
                Pool_ns::PseudoCounterPool &p =
                                pool_dev->get_pseudo_counter(ch_id);
                ch_ptr = &p;
                pcp->ch_elts.push_back(ch_id);
            }
            catch(Tango::DevFailed &e)
            {
                TangoSys_OMemStream o;

                o << "No counter/timer, 0D experiment channel or pseudo ";
                o << "counter with id " << ch_id << " found in the ";
                o << "pool" << ends;

                Tango::Except::re_throw_exception(e,
                    (const char *)"Pool_InvalidPseudoCounterElement",o.str(),
                    (const char *)"PseudoCounter::init_pool_element");
            }
        }

        pcp->user_full_name_extra += ch_ptr->get_name();
        if (ul < co_nb-1)
            pcp->user_full_name_extra += ", ";
        ul++;
    }
}

//+------------------------------------------------------------------
/**
 *	method:	PseudoCounter::dev_state
 *
 *	description:	method to execute "State"
 *	This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 * @return	State Code
 */
//+------------------------------------------------------------------
Tango::DevState PseudoCounter::dev_state()
{
    DEBUG_STREAM << "PseudoCounter::dev_state(): entering... !" << endl;

    update_state_from_channels();

    return get_state();
}

void PseudoCounter::update_state_from_channels(int32_t idx, Tango::DevState ch_state)
{
    if (should_be_in_fault())
    {
        set_state(Tango::FAULT);
    }
    else
    {
        if(idx >= 0)
        {

        }
//
// Read state from channels
//
        Tango::DevState final_state = Tango::ON;
        string &_status = get_status();
        _status = StatusNotSet;

        vector<string>::size_type ch_nb = channel_list.size();
        for(vector<string>::size_type ul = 0; ul < ch_nb; ul++)
        {
            Tango::DevState st = (idx == (int32_t)ul) ? ch_state : ch_mov[ul].proxy->state();

            ch_mov[ul].state = st;

            if(st == Tango::FAULT)
            {
                if (ul != 0)
                    _status += '\n';
                _status += channel_list[ul] + " is in FAULT";
                if(final_state == Tango::ON)
                    final_state = Tango::FAULT;
            }
            else if(st == Tango::UNKNOWN)
            {
                if (ul != 0)
                    _status += '\n';
                _status += channel_list[ul] + " is in UNKNOWN state";
                if(final_state == Tango::ON || final_state == Tango::FAULT)
                    final_state = Tango::UNKNOWN;
            }
            else if(st == Tango::ALARM)
            {
                if (ul != 0)
                    _status += '\n';
                _status += channel_list[ul] + " is in ALARM state";
                if(final_state != Tango::MOVING)
                    final_state = Tango::ALARM;
            }
            else if(st == Tango::MOVING)
            {
                if (ul != 0)
                    _status += '\n';
                _status += channel_list[ul] + " is in ALARM state";
                final_state = Tango::MOVING;
            }
        }
        set_state(final_state);
    }
}

PseudoCounter::ChannelMov &PseudoCounter::get_ch_from_id(Pool_ns::ElementId id)
{
    vector<string>::size_type ch_nb = channel_list.size();
    for(vector<string>::size_type ul = 0; ul < ch_nb; ul++)
    {
        if(ch_mov[ul].id == id)
            return ch_mov[ul];
    }

    TangoSys_OMemStream o;
    o << "The pseudo counter does not contain the channel with id "<< id << ends;
    Tango::Except::throw_exception(
            (const char *)"PseudoCounter_InvalidChannelId",o.str(),
            (const char *)"PseudoCounter::get_ch_from_id");
            
    //Make the compiler quiet
    return *((PseudoCounter::ChannelMov *)NULL);
}


int32_t PseudoCounter::get_ch_idx_from_id(Pool_ns::ElementId id)
{
    vector<string>::size_type ch_nb = channel_list.size();
    for(vector<string>::size_type ul = 0; ul < ch_nb; ul++)
    {
        if(ch_mov[ul].id == id)
            return ul;
    }

    TangoSys_OMemStream o;
    o << "The pseudo counter does not contain the channel with id "<< id << ends;
    Tango::Except::throw_exception(
            (const char *)"PseudoCounter_InvalidChannelId",o.str(),
            (const char *)"PseudoCounter::get_ch_from_id");
            
    //Make the compiler quiet
    return -1;
}

//+------------------------------------------------------------------
/**
 *	method:	PseudoCounter::pool_elem_changed
 *
 *	description: This method is called when the src object has changed
 *               and an event is generated
 *
 * arg(s) : - evt [in]: The event that has occured
 *          - forward_evt [out]: the new internal event data to be sent
 *                               to all listeners
 */
//+------------------------------------------------------------------

void PseudoCounter::pool_elem_changed(Pool_ns::PoolElemEventList &evt_lst,
                                    Pool_ns::PoolElementEvent &forward_evt)
{
//
// State change from a channel
//
    Pool_ns::PoolElementEvent *evt = evt_lst.back();

    forward_evt.priority = evt->priority;

    switch(evt->type)
    {
        case Pool_ns::StateChange:
        {
            Tango::DevState old_state = get_state();

            int32_t idx = get_ch_idx_from_id(evt->src->id);

            Tango::DevState new_state = static_cast<Tango::DevState>(evt->curr.state);
            update_state_from_channels(idx, new_state);

            new_state = get_state();

            if(old_state != new_state)
            {
                Tango::AutoTangoMonitor synch(this);
                Tango::MultiAttribute *dev_attrs = get_device_attr();
                Tango::Attribute &state_att = dev_attrs->get_attr_by_name("State");
                state_att.fire_change_event();
            }

            forward_evt.type = Pool_ns::StateChange;
            forward_evt.old.state = Pool_ns::PoolTango::toPool(old_state);
            forward_evt.curr.state = Pool_ns::PoolTango::toPool(new_state);
        }
        break;

//
//  value change event from a Counter/timer
//
        case Pool_ns::CTValueChange:
        case Pool_ns::ZeroDValueChange:
        case Pool_ns::PseudoCoValueChange:
        {
            Tango::DevState pc_state = get_state();

            int32_t idx = get_ch_idx_from_id(evt->src->id);

            ch_values[idx] = evt->curr.value;

            forward_evt.type = Pool_ns::PseudoCoValueChange;
            forward_evt.old.value = value;

            calc();

            Tango::MultiAttribute *attr_list = get_device_attr();
            Tango::Attribute &attr = attr_list->get_attr_by_name ("Value");

            // Make sure the event is sent to all clients
            if(true == evt->priority)
                attr.set_change_event(true,false);

            {
                // get the tango synchronization monitor
                Tango::AutoTangoMonitor synch(this);

                // set the attribute value
                attr.set_value (attr_Value_read);

                if (pc_state == Tango::MOVING)
                    attr.set_quality(Tango::ATTR_CHANGING);
                else if (pc_state == Tango::ALARM)
                    attr.set_quality(Tango::ATTR_ALARM);

                // push the event
                attr.fire_change_event();
            }

            if(true == evt->priority)
                attr.set_change_event(true,true);

            forward_evt.priority = evt->priority;
            forward_evt.curr.value = value;
            forward_evt.dim = 1;
        }
        break;

        default:
        {
            assert(false);
        }
        break;
    }
}

//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::get_device_property()
//
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void PseudoCounter::get_device_property()
{
    //	Initialize your default values here (if not done with  POGO).
    //------------------------------------------------------------------
    PoolIndBaseDev::get_device_property();
    
    //	Read device properties from database.(Automatic code generation)
    //------------------------------------------------------------------
    Tango::DbData	dev_prop;
    dev_prop.push_back(Tango::DbDatum("Channel_list"));

    //	Call database and extract values
    //--------------------------------------------
    if (Tango::Util::instance()->_UseDb==true)
        get_db_device()->get_property(dev_prop);
    Tango::DbDatum	def_prop, cl_prop;
    PseudoCounterClass	*ds_class =
        (static_cast<PseudoCounterClass *>(get_device_class()));
    int	i = -1;

    //	Try to initialize Channel_list from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  channel_list;
    //	Try to initialize Channel_list from default device value
    def_prop = ds_class->get_default_device_property(dev_prop[i].name);
    if (def_prop.is_empty()==false)	def_prop  >>  channel_list;
    //	And try to extract Channel_list value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  channel_list;

    //	End of Automatic code generation
    //------------------------------------------------------------------

}
//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::always_executed_hook()
//
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void PseudoCounter::always_executed_hook()
{
    if (should_be_in_fault())
    {
        set_state(Tango::FAULT);
    }
}
//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::read_attr_hardware
//
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void PseudoCounter::read_attr_hardware(vector<long> &attr_list)
{
    DEBUG_STREAM << "PseudoCounter::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
    //	Add your own code here
}
//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::read_ChannelList
//
// description : 	Extract real attribute values for ChannelList acquisition result.
//
//-----------------------------------------------------------------------------
void PseudoCounter::read_ChannelList(Tango::Attribute &attr)
{
    DEBUG_STREAM << "PseudoCounter::read_ChannelList(Tango::Attribute &attr) entering... "<< endl;

    vector<Tango::DevLong>::iterator ite;
    int32_t l = 0;
    for (ite = channel_list.begin();ite != channel_list.end();++ite)
    {
        Pool_ns::ElementId ch_id = (Pool_ns::ElementId)*ite;
        Pool_ns::PoolElement &ch = pool_dev->get_experiment_channel(ch_id);
        attr_ChannelList_read[l++] = const_cast<char *>(ch.get_name().c_str());
    }

    attr.set_value(attr_ChannelList_read, channel_list.size());
}

//+------------------------------------------------------------------
/**
 *	method:	PseudoCounter::dev_status
 *
 *	description:	method to execute "Status"
 *	This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *
 * @return	Status descrition
 *
 */
//+------------------------------------------------------------------
Tango::ConstDevString PseudoCounter::dev_status()
{
    Tango::ConstDevString	argout = DeviceImpl::dev_status();
    DEBUG_STREAM << "PseudoCounter::dev_status(): entering... !" << endl;

    //	Add your own code to control device here
    return argout;
}

//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::read_Value
//
// description : 	Extract real attribute values for Value acquisition result.
//
//-----------------------------------------------------------------------------
void PseudoCounter::read_Value(Tango::Attribute &attr)
{
    DEBUG_STREAM << "PseudoCounter::read_Value(Tango::Attribute &attr) entering... "<< endl;

//
// Read values from channels
//
    vector<string>::size_type ch_nb = channel_list.size();
    double tmp_v;
    for(vector<string>::size_type ul = 0; ul < ch_nb; ul++)
    {
        Tango::DeviceAttribute val_attr =
            ch_mov[ul].proxy->read_attribute(ch_mov[ul].type == ZEROD ? "CumulatedValue" : "Value");
        val_attr >> tmp_v;
        ch_values[ul] = tmp_v;
    }

    calc();

    attr.set_value(attr_Value_read);
}

//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::calc
//
// description : 	Extract real attribute values for Value acquisition result.
//
//-----------------------------------------------------------------------------
double PseudoCounter::calc()
{
    Pool_ns::PseudoCoCtrlFiCa *pc_fica = get_pc_fica_ptr();

///
/// Pass the counter values the Python Pseudo Controller
/// to get the pseudo counter value.
///
    Pool_ns::AutoPoolLock lo(pc_fica->get_mon());
    value = get_pc_ctrl()->Calc(get_axis(), ch_values);
    return value;
}

//+------------------------------------------------------------------
/**
 *	method:	PseudoCounter::start
 *
 *	description:	method to execute "Start"
 *	Start counting
 *
 *
 */
//+------------------------------------------------------------------
void PseudoCounter::start()
{
    DEBUG_STREAM << "PseudoCounter::start(): entering... !" << endl;

    //	Add your own code to control device here
    TangoSys_OMemStream o;
    o << "Start operation not implemented yet!";
    o << "\nPlease wait for a newer version";

    Tango::Except::throw_exception(
            (const char *)"PseudoCounter_MethodNotImplemented",o.str(),
            (const char *)"Pool::start");

}

//+------------------------------------------------------------------
/**
 *	method:	PseudoCounter::abort
 *
 *	description:	method to execute "Abort"
 *	Stop counting
 *
 *
 */
//+------------------------------------------------------------------
void PseudoCounter::abort()
{
    DEBUG_STREAM << "PseudoCounter::abort(): entering... !" << endl;

    //	Add your own code to control device here
    base_abort(true);
}

//+------------------------------------------------------------------
/**
 *	method:	PseudoCounter::abort
 *
 *	description:	method to execute "Abort"
 *	Stop counting
 *
 *
 */
//+------------------------------------------------------------------
void PseudoCounter::base_abort(bool send_evt)
{
    DEBUG_STREAM << "PseudoCounter::abort(): entering... !" << endl;

    //	Add your own code to control device here
    TangoSys_OMemStream o;
    o << "Abort operation not implemented yet!";
    o << "\nPlease wait for a newer version";

    Tango::Except::throw_exception(
            (const char *)"PseudoCounter_MethodNotImplemented",o.str(),
            (const char *)"Pool::abort");
}

PseudoCounterController *PseudoCounter::get_pc_ctrl()
{
    return static_cast<PseudoCounterController *>(get_controller());
}

Pool_ns::PseudoCoCtrlFiCa *PseudoCounter::get_pc_fica_ptr()
{
    return static_cast<Pool_ns::PseudoCoCtrlFiCa*>(fica_ptr);
}

}	//	namespace
